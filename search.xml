<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[快捷键说明]]></title>
    <url>%2Fpost%2Fbbbae7cf.html</url>
    <content type="text"><![CDATA[搜索框 Key Descption ESC 1.如果输入框有内容，清除内容 2.如果输入框无内容，失去焦点 i/I 获取焦点，使用I，不然和vimium插件冲突 下 向下选择文章 上 向上选择文章 回车 打开当前选中的文章，若没有，则默认打开第一个 全局 Key Descption s/S 全屏/取消全屏 w/W 打开/关闭文章目录 j/J 向下滑动 k/K 向上滑动 gg/GG 到最顶端 shift+G/g 到最下端]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写作规范]]></title>
    <url>%2Fpost%2F15159e71.html</url>
    <content type="text"><![CDATA[文章生成所有文章生成，都必须使用命令的方式，文章的名称必须加引号，防止有空格等特殊符号，然后把生成的md文件移动到指定的文件夹归类，一定不要直接放在_posts下： hexo new &#39;文章名称&#39; hexo new draft &#39;文章名称&#39; Front-Matter设置在./scaffolds/post.md模板文件设置好前言后，不要在其它地方修改格式： --- title: {{ title }} date: {{ date }} tags: - categories: - top: false comments: false typora-copy-images-to: ../images --- 标签如果想多个标签可以有如下操作，所有标签都在下面列出来，新增必须在下面添加，如果是英文的话，全部使用驼峰命名法： tags: - 标签1 - 标签2 分类如果想有子分类，可以如下操作，但是不建议有太多层级的分类： categories: - 父分类 - 子分类 注意：-符号后面个空格 图片资源统一放在./source/images/目录下 typora-copy-images-to: ../../images 文章版式目录文章不使用H1标题，因为Front-Matter已经自动生成了； 文章一级目录使用H2，二级目录使用H3，以此类推； 内容提示如果使用提示，使用红色标出，例如请注意！]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tp3.2使用心得]]></title>
    <url>%2Fpost%2F525017a6.html</url>
    <content type="text"><![CDATA[入口文件配置应用入口index.php常量配置； 常用配置app_debug开启调试模式，影响如下： 将加载，$runtimefile = RUNTIME_PATH . APP_MODE . &#39;~runtime.php&#39;; define(&#39;APP_DEBUG&#39;, true); //默认是关闭调试模式 defined(&#39;APP_DEBUG&#39;) or define(&#39;APP_DEBUG&#39;, false); // 是否调试模式 confg_extdefined(&#39;CONF_EXT&#39;) or define(&#39;CONF_EXT&#39;, &#39;.php&#39;); // 配置文件后缀 conf_parsedefined(&#39;CONF_PARSE&#39;) or define(&#39;CONF_PARSE&#39;, &#39;&#39;); // 配置文件解析方法 app_mode定义应用模式，默认为普通模式，有以下模式，定义不同的模式将加载不同的Mode核心文件（ThinkPHP/Mode目录下的模式配置文件），主要是加载一些核心文件，设置配置，别名，行为标签啥的； API模式定义 普通模式定义 Lite模式定义 SAE应用模式定义文件 如果CONF_PATH . ‘core.php’存在的话，则读取这个，不读取模式目录下的配置文件； //默认 defined(&#39;APP_MODE&#39;) or define(&#39;APP_MODE&#39;, &#39;common&#39;); // 应用模式 默认为普通模式 storage_type存储类型，默认为File defined(&#39;STORAGE_TYPE&#39;) or define(&#39;STORAGE_TYPE&#39;, &#39;File&#39;); // 存储类型 默认为File 目录结构app_path定义应用目录，影响如下： 可以修改应用目录的位置； 可以修改应用目录的名称； 如果不定义就是在index.php的位置，代码目录就会混乱 并且影响一下几个默认的目录结构 define(&#39;APP_PATH&#39;, &#39;./Application/&#39;); //默认 defined(&#39;APP_PATH&#39;) or define(&#39;APP_PATH&#39;, dirname($_SERVER[&#39;SCRIPT_FILENAME&#39;]) . &#39;/&#39;); runtime_path系统运行时目录，存一些临时文件，默认在应用目录下Runtime目录 defined(&#39;RUNTIME_PATH&#39;) or define(&#39;RUNTIME_PATH&#39;, APP_PATH . &#39;Runtime/&#39;); // 系统运行时目录 log_path应用日志目录，默认在应用运行目录下 defined(&#39;LOG_PATH&#39;) or define(&#39;LOG_PATH&#39;, RUNTIME_PATH . &#39;Logs/&#39;); // 应用日志目录 temp_path应用缓存目录，默认在应用运行目录下 defined(&#39;TEMP_PATH&#39;) or define(&#39;TEMP_PATH&#39;, RUNTIME_PATH . &#39;Temp/&#39;); // 应用缓存目录 data_path应用数据目录，默认在应用运行目录下 defined(&#39;DATA_PATH&#39;) or define(&#39;DATA_PATH&#39;, RUNTIME_PATH . &#39;Data/&#39;); // 应用数据目录 cache_path应用模板缓存目录，默认在应用运行目录下 defined(&#39;CACHE_PATH&#39;) or define(&#39;CACHE_PATH&#39;, RUNTIME_PATH . &#39;Cache/&#39;); // 应用模板缓存目录 common_path应用公共目录，默认在应用目录下 defined(&#39;COMMON_PATH&#39;) or define(&#39;COMMON_PATH&#39;, APP_PATH . &#39;Common/&#39;); // 应用公共目录 config_path应用配置目录，默认在公共目录下 defined(&#39;CONF_PATH&#39;) or define(&#39;CONF_PATH&#39;, COMMON_PATH . &#39;Conf/&#39;); // 应用配置目录 lang_path 应用语言，默认在应用公共目录下 defined(&#39;LANG_PATH&#39;) or define(&#39;LANG_PATH&#39;, COMMON_PATH . &#39;Lang/&#39;); // 应用语言目录 html_path应用静态目录，默认在应用目录下 defined(&#39;HTML_PATH&#39;) or define(&#39;HTML_PATH&#39;, APP_PATH . &#39;Html/&#39;); // 应用静态目录 addon_path插件目录 defined(&#39;ADDON_PATH&#39;) or define(&#39;ADDON_PATH&#39;, APP_PATH . &#39;Addon&#39;); think_path定义核心文件位置，默认值就是ThinkPhp的目录 defined(&#39;THINK_PATH&#39;) or define(&#39;THINK_PATH&#39;, __DIR__ . &#39;/&#39;); lib_path系统核心类库目录 defined(&#39;LIB_PATH&#39;) or define(&#39;LIB_PATH&#39;, realpath(THINK_PATH . &#39;Library&#39;) . &#39;/&#39;); // 系统核心类库目录 core_pathThink类库目录 defined(&#39;CORE_PATH&#39;) or define(&#39;CORE_PATH&#39;, LIB_PATH . &#39;Think/&#39;); // Think类库目录 behavior_path行为类库目录 defined(&#39;BEHAVIOR_PATH&#39;) or define(&#39;BEHAVIOR_PATH&#39;, LIB_PATH . &#39;Behavior/&#39;); // 行为类库目录 其它访问常量IS_CGIIS_WINIS_CLI__PHP_FILE__cgi请求时候，脚本的脚本的的相对documen_root地址，cli模式不需要，因为本身就需要输入脚本地址； __ROOT____PHP_FILE_的目录，也就脚本的相对目录 NOW_TIMEREQUEST_METHODIS_GETIS_POSTIS_PUTIS_DELETEIS_AJAXMODULE_NAME获取模块名称 MODULE_PATH当前模块路径 CONTROLLER_NAMECONTROLLER_PATHACTION_NAME命名空间 要使用命名空间加载，则类名里必须包含\，如果關閉命名空間的話，則还有还有另外一套规则，忽略； 1、首先看Think\Think::$_map[$class],有没有映射； 其实就是设置的类别名： 模式配置文件下有设置一些别名； CONF_PATH . &#39;alias.php&#39;文件可以设置别名； 2、命名空间的首个单词为’Think’, ‘Org’, ‘Behavior’, ‘Com’, ‘Vendor’的，或者lib_path目录下存在命名空间的首个单词目录则： 加载LIB_PATH.命名空间.php文件，起始命名空间就像是相对目录，就是绝对目录和相对目录的拼接； 3、检测自定义命名空间 否则就以模块为命名空间： return [ &#39;AUTOLOAD_NAMESPACE&#39;=&gt;[ &#39;命名空间的首个单词1&#39;=&gt;&#39;目录/&#39;, ] ]; 4、否则的话: $path = APP_PATH; 配置惯例配置 -&gt;应用配置，common/config.php -&gt;应用模式配置（不是common模式） -&gt;THINK_PATH . &#39;Conf/debug.php&#39;(开启调试模式的话) -&gt;CONF_PATH . &#39;debug&#39; . CONF_EXT（开启调试模式的话） -&gt;CONF_PATH . APP_STATUS . CONF_EXT（状态配置） 这一部分会改变COMMON_PATH -&gt; COMMON_PATH. &#39;Common/&#39; . $file . &#39;.php&#39;(扩展配置，LOAD_EXT_FILE配置) return [ &#39;LOAD_EXT_FILE&#39;=&gt;&#39;文件名1,文件名2&#39; ]; -&gt;LOAD_EXT_CONFIG配置 return [ &#39;LOAD_EXT_CONFIG&#39;=&gt;&#39;完整的文件路径1,完整的文件路径2&#39; ]; // $path . &#39;Conf/&#39;.文件名.php return [ &#39;LOAD_EXT_CONFIG&#39;=&gt;&#39;文件名1,文件名2&#39; ]; return [ &#39;LOAD_EXT_CONFIG&#39;=&gt;[ &#39;key&#39;=&gt;类似上面两种, ] ]; 这一部分是模块 -&gt;模块配置conf.php -&gt;模块模式配置&#39;Conf/config_&#39; . APP_MODE . CONF_EXT -&gt;模块应用状态配置&#39;Conf/&#39; . APP_STATUS . CONF_EXT -&gt;模块别名文件Conf/alias.php -&gt;模块标签文件’Conf/tags.php’ -&gt;加载函数模块下的’Common/function.php’; -&gt;加载模块的额外文件，模块下的’Common/‘ . $file . ‘.php’;与应用相同 -&gt;加载额外的配置，与应用LOAD_EXT_CONFIG相同 配置文件格式 return [ // 日志目录转换为绝对路径 默认情况下存储到公共模块下面 &#39;LOG_PATH&#39;=&gt;C(&#39;LOG_PATH&#39;, realpath(LOG_PATH) . &#39;/Common/&#39;), // 全局安全过滤,$_REQUEST,$_POST,$_GET &#39;REQUEST_VARS_FILTER&#39;=&gt;true, ]; 行为标签系统默认的有 url_dispatch app_init，app初始化 module_config，模块配置完成 标签基本配置 标签定义 在模式配置文件中可以定义行为参数； CONF_PATH . &#39;tags.php&#39;文件中定义 array( &#39;app_init&#39; =&gt; array( &#39;Behavior\BuildLiteBehavior&#39;, // 生成运行Lite文件 ), &#39;app_begin&#39; =&gt; array( &#39;Behavior\ReadHtmlCacheBehavior&#39;, // 读取静态缓存 ), &#39;app_end&#39; =&gt; array( &#39;Behavior\ShowPageTraceBehavior&#39;, // 页面Trace显示 ), &#39;view_parse&#39; =&gt; array( &#39;Behavior\ParseTemplateBehavior&#39;, // 模板解析 支持PHP、内置模板引擎和第三方模板引擎 ), &#39;template_filter&#39; =&gt; array( &#39;Behavior\ContentReplaceBehavior&#39;, // 模板输出替换 ), &#39;view_filter&#39; =&gt; array( &#39;Behavior\WriteHtmlCacheBehavior&#39;, // 写入静态缓存 ), ), 监听标签 Hook::listen(&#39;app_init&#39;); 执行标签 Hook::exec($插件名称, $方法名（标签名，如果是Behavior结尾的类则被替换run）, $params)； //new $插件名称()-&gt;$方法名($params); 调试记录和统计时间（微秒）和内存使用情况 * &lt;code&gt; * G(&#39;begin&#39;); // 记录开始标记位 * // ... 区间运行代码 * G(&#39;end&#39;); // 记录结束标签位 * echo G(&#39;begin&#39;,&#39;end&#39;,6); // 统计区间运行时间 精确到小数后6位 * echo G(&#39;begin&#39;,&#39;end&#39;,&#39;m&#39;); // 统计区间内存使用情况 * 如果end标记位没有定义，则会自动以当前作为标记位 * 其中统计内存使用需要 MEMORY_LIMIT_ON 常量为true才有效 * &lt;/code&gt; trace 开启配置 &#39;TRACE_EXCEPTION&#39;=&gt;true Log::save(); 路由url基础设置URL大小写，解决linux下大小写的问题 &#39;URL_CASE_INSENSITIVE&#39; =&gt; true, &#39;URL_DENY_SUFFIX&#39; =&gt; &#39;ico|png|gif|jpg&#39;, // URL禁止访问的后缀设置 url模式 普通模式 普通模式也就是传统的GET传参方式来指定当前访问的模块和操作，例如： http://localhost/?m=home&amp;c=user&amp;a=login&amp;var=value [ &#39;URL_MODEL&#39;=&gt;0, // m参数表示模块，c参数表示控制器，a参数表示操作，后面的表示其他GET参数 &#39;VAR_MODULE&#39; =&gt; &#39;m&#39;, // 默认模块获取变量 &#39;VAR_CONTROLLER&#39; =&gt; &#39;c&#39;, // 默认控制器获取变量 &#39;VAR_ACTION&#39; =&gt; &#39;a&#39;, // 默认操作获取变量 ] PATHINFO模式 默认URL模式，提供了最好的SEO支持，URL访问地址是： http://localhost/index.php/home/user/login/var/value/; 可以采用普通URL模式的参数方式，例如： http://localhost/index.php/home/user/login?var=value 依然是有效的 &#39;URL_PATHINFO_DEPR&#39;=&gt;&#39;/&#39;, &#39;URL_MODEL&#39;=&gt;&#39;1&#39;, REWRITE模式 PATHINFO模式的基础上，可以去掉URL地址里面的入口文件index.php,需要配置nginx重新规则 &#39;URL_MODEL&#39;=&gt;&#39;2&#39;, 兼容模式 需要配置VAR_PATHINFO参数，用来获取path_info，主要对于那些不支持path_info服务器 [ &#39;URL_MODEL&#39;=&gt;3, // 兼容模式PATHINFO获取变量例如 ?s=/module/action/id/1 后面的参数取决于URL_PATHINFO_DEPR &#39;VAR_PATHINFO&#39;=&gt; &#39;s&#39;, &#39;URL_PATHINFO_DEPR&#39;=&gt;&#39;/&#39;, // 用于兼容判断PATH_INFO 参数的SERVER替代变量列表 &#39;URL_PATHINFO_FETCH&#39; =&gt; &#39;ORIG_PATH_INFO,REDIRECT_PATH_INFO,REDIRECT_URL&#39;, ] 域名路由域名指向特定的模块；规则为：&#39;子域名&#39;=&gt;array(&#39;模块名[/控制器名]&#39;,&#39;var1=a&amp;var2=b&#39;); return [ &#39;APP_SUB_DOMAIN_DEPLOY&#39; =&gt; true, &#39;APP_SUB_DOMAIN_RULES&#39; =&gt; array( &#39;free.mozhan.com&#39; =&gt;&#39;Free&#39;, &#39;admin.mozhan.com&#39; =&gt; &#39;Admin&#39;, //&#39;user.mozhan.com:8080&#39; =&gt; &#39;User&#39;, &#39;user.mozhan.com&#39; =&gt; &#39;User&#39;, &#39;user5.zhongyidong.com&#39; =&gt; &#39;User&#39;, &#39;user.xuanchuanyi.com&#39; =&gt; &#39;User&#39;, &#39;user.258weishi.com&#39; =&gt; &#39;User&#39;, &#39;user2.weitang.com&#39; =&gt; &#39;User&#39;, &#39;interFaces.mozhan.com&#39; =&gt; &#39;InterFaces&#39;, &#39;api.mozhan.com&#39; =&gt; &#39;Api&#39;, &#39;plugins.mozhan.com&#39; =&gt; &#39;Plugins&#39;, &#39;k.mozhan.com&#39;=&gt; &#39;Quick&#39;, &#39;*&#39; =&gt; &#39;Home&#39;, // 二级泛域名指向Home模块 ), ]; 控制台脚本的第一个参数就当做pathinfo $_SERVER[&#39;PATH_INFO&#39;] = isset($_SERVER[&#39;argv&#39;][1]) ? $_SERVER[&#39;argv&#39;][1] : &#39;&#39;; http处理重定向 send_http_status(404); exit; 错误处理异常处理抛出Think\Exception($msg, $code)异常 E($msg, $code = 0) 模型实例化时候的方法 protected _initialize () { } 添加错误信息 $this-&gt;error = L(&#39;_DATA_TYPE_INVALID_&#39;); 获取插入id $insertId = $this-&gt;getLastInsID(); 获取sql $sql = $User-&gt;fetchSql(true)-&gt;add($data); 实例化new方法实例化 D方法实例化 不需要传递完整的类名，当 \Home\Model\UserModel 类不存在的时候，D函数会尝试实例化公共模块下面的 \Common\Model\UserModel 类，默认是实例化当前模块下的Model //实例化模型 $User = D(&#39;User&#39;); // 相当于 $User = new \Home\Model\UserModel(); //D方法还可以支持跨模块调用，需要使用： //实例化Admin模块的User模型 D(&#39;Admin/User&#39;); //实例化Extend扩展命名空间下的Info模型 D(&#39;Extend://Editor/Info&#39;); M方法实例化 性能会比较高 // 使用M方法实例化 $User = M(&#39;User&#39;); // 和用法 $User = new \Think\Model(&#39;User&#39;); 等效 // 执行其他的数据操作 $User-&gt;select(); M方法也可以支持跨库操作，例如： // 使用M方法实例化 操作db_name数据库的ot_user表$User = M(&#39;db_name.User&#39;,&#39;ot_&#39;);// 执行其他的数据操作$User-&gt;select(); 实例化空模型类，单单用于执行sql时候 //实例化空模型 $Model = new Model(); //或者使用M快捷方法是等效的 $Model = M(); //进行原生的SQL查询 $Model-&gt;query(&#39;SELECT * FROM think_user WHERE status = 1&#39;); 字段缓存不是调试模式都会再Runtime/Data/_fields/生成字段缓存； 关闭字段缓存，在mysql配置里 // 关闭字段缓存 &#39;DB_FIELDS_CACHE&#39;=&gt;false 在调试模式中默认是关闭的，但是测试的时候好像没有关闭； 部署模式下，最后要清除缓存文件； 手动定义字段 如果不行用缓存，又想提高效率则可以手动定义，但是不推荐 namespace Home\Model; use Think\Model; class UserModel extends Model { protected $fields = array(&#39;id&#39;, &#39;username&#39;, &#39;email&#39;, &#39;age&#39;); protected $pk = &#39;id&#39;; } 还可以定义字段类型 namespace Home\Model; use Think\Model; class UserModel extends Model { protected $fields = array(&#39;id&#39;, &#39;username&#39;, &#39;email&#39;, &#39;age&#39;, &#39;_type&#39;=&gt;array(&#39;id&#39;=&gt;&#39;bigint&#39;,&#39;username&#39;=&gt;&#39;varchar&#39;,&#39;email&#39;=&gt;&#39;varchar&#39;,&#39;age&#39;=&gt;&#39;int&#39;) ); } 数据库配置 数组方式配置 调试模式配置 //数据库配置信息 &#39;DB_TYPE&#39; =&gt; &#39;mysql&#39;, // 数据库类型 &#39;DB_HOST&#39; =&gt; &#39;localhost&#39;, // 服务器地址 &#39;DB_NAME&#39; =&gt; &#39;thinkphp&#39;, // 数据库名 &#39;DB_USER&#39; =&gt; &#39;root&#39;, // 用户名 &#39;DB_PWD&#39; =&gt; &#39;123456&#39;, // 密码 &#39;DB_PORT&#39; =&gt; 3306, // 端口 &#39;DB_PREFIX&#39; =&gt; &#39;think_&#39;, // 数据库表前缀 &#39;DB_CHARSET&#39;=&gt; &#39;utf8&#39;, // 字符集 &#39;DB_DEBUG&#39; =&gt; TRUE, // 数据库调试模式 开启后可以记录SQL日志 3.2.3新增 数据库的类型由DB_TYPE参数设置 DB_TYPE设置 支持的数据库类型 mysql或mysqli mysql pgsql pgsql sqlite sqlite mssql 或sqlsrv sqlserver oracle oracle ibase ibase mongo mongo PDO PDO支持的所有数据库 3.2.3以上版本取消了PDO设置 DB_SN方式配置 格式为，数据库类型://用户名:密码@数据库地址:数据库端口/数据库名#字符集 //PDO连接方式 &#39;DB_TYPE&#39; =&gt; &#39;pdo&#39;, // 数据库类型 &#39;DB_USER&#39; =&gt; &#39;root&#39;, // 用户名 &#39;DB_PWD&#39; =&gt; &#39;&#39;, // 密码 &#39;DB_PREFIX&#39; =&gt; &#39;think_&#39;, // 数据库表前缀 &#39;DB_DSN&#39; =&gt; &#39;mysql:host=localhost;dbname=thinkphp;charset=utf8&#39; 还可以在模式属性中定义，实例化传递参数时候定义； 切换数据库分布式数据库开启来DB_DEPLOY_TYPE = 1； &#39;DB_DEPLOY_TYPE&#39; =&gt; 0, // 数据库部署方式:0 集中式(单一服务器),1 分布式(主从服务器) &#39;DB_RW_SEPARATE&#39; =&gt; false, // 数据库读写是否分离 主从式有效 &#39;DB_MASTER_NUM&#39; =&gt; 1, // 读写分离后 主服务器数量 &#39;DB_SLAVE_NO&#39; =&gt; &#39;&#39;, // 指定从服务器序号 查询方法命名范围 _scope属性定义 namespace Home\Model; use Think\Model; class NewsModel extends Model { protected $_scope = array( // 命名范围normal &#39;normal&#39;=&gt;array( &#39;where&#39;=&gt;array(&#39;status&#39;=&gt;1), ), // 命名范围latest &#39;latest&#39;=&gt;array( &#39;order&#39;=&gt;&#39;create_time DESC&#39;, &#39;limit&#39;=&gt;10, ), ); } 使用scope方法进行命名范围的调用 $Model = D(&#39;News&#39;); // 这里必须使用D方法 因为命名范围在模型里面定义 $Model-&gt;scope(&#39;normal&#39;)-&gt;select(); $Model-&gt;scope(&#39;latest&#39;)-&gt;select(); 连贯调用： 两个命名范围的定义存在冲突，则后面调用的命名范围定义会覆盖前面的相同属性的定义； 调用的命名范围标识不存在，则会忽略该命名范围 $Model-&gt;scope(&#39;normal&#39;)-&gt;scope(&#39;latest&#39;)-&gt;select(); //简化 $Model-&gt;scope(&#39;normal,latest&#39;)-&gt;select(); 默认命名范围 protected $_scope = array( // 默认的命名范围 &#39;default&#39;=&gt;array( &#39;where&#39;=&gt;array(&#39;status&#39;=&gt;1), &#39;limit&#39;=&gt;10, ), ); 调用 // 无需传递参数 $Model-&gt;scope()-&gt;select(); // 或则 $Model-&gt;scope(&#39;default&#39;)-&gt;select(); 命名范围调整 增加额外的调整，覆盖或者添加 $Model-&gt;scope(&#39;normal&#39;,array(&#39;limit&#39;=&gt;5))-&gt;select(); 多个范围调整，覆盖前面的 $Model-&gt;scope(&#39;normal,latest&#39;,array(&#39;limit&#39;=&gt;5))-&gt;select(); 自定义命名范围 调用的时候定义 $Model-&gt;scope(array(&#39;field&#39;=&gt;&#39;id,title&#39;,&#39;limit&#39;=&gt;5,&#39;where&#39;=&gt;&#39;status=1&#39;,&#39;order&#39;=&gt;&#39;create_time DESC&#39;))-&gt;select(); 连贯操作 如果定义的命名范围和连贯操作的属性有冲突，则后面调用的会覆盖前面的 $Model-&gt;scope(&#39;normal&#39;)-&gt;limit(8)-&gt;order(&#39;id desc&#39;)-&gt;select(); 动态调用 $Model-&gt;scope(&#39;normal&#39;,array(&#39;limit&#39;=&gt;5))-&gt;select(); // 等价 $Model-&gt;normal(array(&#39;limit&#39;=&gt;5))-&gt;select(); 数据创建 基础创建 自动根据表单数据创建数据对象，使用add或者save方法才会真正写入数据库 // 实例化User模型 $User = M(&#39;User&#39;); // 根据表单提交的POST数据创建数据对象 $User-&gt;create(); //或者 $data[&#39;name&#39;] = &#39;ThinkPHP&#39;; $data[&#39;email&#39;] = &#39;ThinkPHP@gmail.com&#39;; $User-&gt;create($data); 对象创建新的数据对象 第二个参数可以指定创建数据的操作状态，表示是插入还是更新，默认是自动判断 $Member = M(&quot;User&quot;); // 指定更新数据操作状态 $Member-&gt;create($_POST,Model::MODEL_UPDATE); 流程 步骤 说明 返回 1 获取数据源（默认是POST数组） 2 验证数据源合法性（非数组或者对象会过滤） 失败则返回false 3 检查字段映射 4 判断数据状态（新增或者编辑，指定或者自动判断） 5 数据自动验证 失败则返回false 6 表单令牌验证 失败则返回false 7 表单数据赋值（过滤非法字段和字符串处理） 8 数据自动完成 9 生成数据对象（保存在内存） data方法，不需要数据验证啥的时候使用 可以自动过滤一些不存在的字段（不存在的字段，非法的数据类型） // 实例化User模型 $User = M(&#39;User&#39;); // 创建数据后写入到数据库 $data[&#39;name&#39;] = &#39;ThinkPHP&#39;; $data[&#39;email&#39;] = &#39;ThinkPHP@gmail.com&#39;; $User-&gt;data($data)-&gt;add(); 字段合法性验证 在create方法之前调用field方法； $data[&#39;name&#39;] = &#39;thinkphp&#39;; $data[&#39;email&#39;] = &#39;thinkphp@gmail.com&#39;; $data[&#39;status&#39;] = 1; $data[&#39;test&#39;] = &#39;test&#39;; $User = M(&#39;User&#39;); $data = $User-&gt;field(&#39;name,email&#39;)-&gt;create($data); dump($data); 自定义模型类 namespace Home\Model; use Think\Model; class UserModel extends Model{ protected $insertFields = &#39;name,email&#39;; // 新增数据的时候允许写入name和email字段 protected $updateFields = &#39;email&#39;; // 编辑数据的时候只允许写入email字段 } 数据写入 使用add方法 $User = M(&quot;User&quot;); // 实例化User对象 $data[&#39;name&#39;] = &#39;ThinkPHP&#39;; $data[&#39;email&#39;] = &#39;ThinkPHP@gmail.com&#39;; $User-&gt;add($data); 字段内容过滤 过filter方法可以对数据的值进行过滤处理 $data[&#39;name&#39;] = &#39;&lt;b&gt;thinkphp&lt;/b&gt;&#39;; $data[&#39;email&#39;] = &#39;thinkphp@gmail.com&#39;; $User = M(&#39;User&#39;); // 字段内容strip_tags转换 $User-&gt;data($data)-&gt;filter(&#39;strip_tags&#39;)-&gt;add(); 批量写入 // 批量添加数据 $dataList[] = array(&#39;name&#39;=&gt;&#39;thinkphp&#39;,&#39;email&#39;=&gt;&#39;thinkphp@gamil.com&#39;); $dataList[] = array(&#39;name&#39;=&gt;&#39;onethink&#39;,&#39;email&#39;=&gt;&#39;onethink@gamil.com&#39;); $User-&gt;addAll($dataList); 数据读取 find()读取数据表中的第一行数据 查询出错，find方法返回false; 如果查询结果为空返回NULL 成功则返回一个关联数组 $User = M(&quot;User&quot;); // 实例化User对象 // 查找status值为1name值为think的用户数据 $data = $User-&gt;where(&#39;status=1 AND name=&quot;thinkphp&quot;&#39;)-&gt;find(); dump($data); select()多行记录 查询出错，select的返回值是false 如果查询结果为空，则返回NULL 否则返回二维数组 $User = M(&quot;User&quot;); // 实例化User对象 // 查找status值为1的用户数据 以创建时间排序 返回10条数据 $list = $User-&gt;where(&#39;status=1&#39;)-&gt;order(&#39;create_time&#39;)-&gt;limit(10)-&gt;select(); getField()，获取字段值 第一行的字段值 $User = M(&quot;User&quot;); // 实例化User对象 // 获取ID为3的用户的昵称 $nickname = $User-&gt;where(&#39;id=3&#39;)-&gt;getField(&#39;nickname&#39;); 整列的字段值 $User-&gt;getField(&#39;id&#39;,true); // 获取id数组 //返回数据格式如array(1,2,3,4,5)一维数组，其中value就是id列的每行的值 两个字段 $User = M(&quot;User&quot;); // 实例化User对象 // 获取所有用户的ID和昵称列表 $list = $User-&gt;getField(&#39;id,nickname&#39;); //两个字段的情况下返回的是array(`id`=&gt;`nickname`)的关联数组，以id的值为key，nickname字段值为value 多个字段的名称 $list = $User-&gt;getField(&#39;id,nickname,email&#39;); //返回的数组格式是array(`id`=&gt;array(`id`=&gt;value,`nickname`=&gt;value,`email`=&gt;value))是一个二维数组，key还是id字段的值，但value是整行的array数组，类似于select()方法的结果遍历将id的值设为数组key 字符串分隔符 $list = $User-&gt;getField(&#39;id,nickname,email&#39;,&#39;:&#39;); //返回的结果就是一个数组，键名是用户id，键值是 nickname:email的输出字符串 getField方法还可以支持限制数量 $this-&gt;getField(&#39;id,name&#39;,5); // 限制返回5条记录 $this-&gt;getField(&#39;id&#39;,3); // 获取id数组 限制3条记录 更新数据 save方法 返回值是影响的记录数; 返回false则表示更新出错; $User = M(&quot;User&quot;); // 实例化User对象 // 要修改的数据对象属性赋值 $data[&#39;name&#39;] = &#39;ThinkPHP&#39;; $data[&#39;email&#39;] = &#39;ThinkPHP@gmail.com&#39;; $User-&gt;where(&#39;id=5&#39;)-&gt;save($data); // 根据条件更新记录 对象方式来操作 $User = M(&quot;User&quot;); // 实例化User对象 // 要修改的数据对象属性赋值 $User-&gt;name = &#39;ThinkPHP&#39;; $User-&gt;email = &#39;ThinkPHP@gmail.com&#39;; $User-&gt;where(&#39;id=5&#39;)-&gt;save(); // 根据条件更新记录 没有条件的时候，默认条件是主键id值，否则数据对象本身也不包含主键字段的话，save方法不会更新任何数据库的记录; $User = M(&quot;User&quot;); // 实例化User对象 // 要修改的数据对象属性赋值 $data[&#39;id&#39;] = 5;//条件 $data[&#39;name&#39;] = &#39;ThinkPHP&#39;; $data[&#39;email&#39;] = &#39;ThinkPHP@gmail.com&#39;; $User-&gt;save($data); // 根据条件保存修改的数据 setField更新个别字段 更改用户的name值为ThinkPHP $User = M(&quot;User&quot;); // 实例化User对象 // 更改用户的name值 $User-&gt; where(&#39;id=5&#39;)-&gt;setField(&#39;name&#39;,&#39;ThinkPHP&#39;); 更新多个字段 setInc和setDec 统计字段（通常指的是数字类型）的更新 User = M(&quot;User&quot;); // 实例化User对象 $User-&gt;where(&#39;id=5&#39;)-&gt;setInc(&#39;score&#39;,3); // 用户的积分加3 $User-&gt;where(&#39;id=5&#39;)-&gt;setInc(&#39;score&#39;); // 用户的积分加1 $User-&gt;where(&#39;id=5&#39;)-&gt;setDec(&#39;score&#39;,5); // 用户的积分减5 $User-&gt;where(&#39;id=5&#39;)-&gt;setDec(&#39;score&#39;); // 用户的积分减1 //延迟更新 $Article = M(&quot;Article&quot;); // 实例化Article对象 $Article-&gt;where(&#39;id=5&#39;)-&gt;setInc(&#39;view&#39;,1); // 文章阅读数加1 $Article-&gt;where(&#39;id=5&#39;)-&gt;setInc(&#39;view&#39;,1,60); // 文章阅读数加1，并且延迟60秒更新（写入） 删除 delete方法 返回值是删除的记录数； 返回值是false则表示SQL出错 返回值如果为0表示没有删除任何数据 删除主键数据 $Form = M(&#39;Form&#39;); $Form-&gt;delete(5); // $User-&gt;delete(&#39;1,2,5&#39;); // 删除主键为1,2和5的用户数据 根据条件删除 $User = M(&quot;User&quot;); // 实例化User对象 $User-&gt;where(&#39;id=5&#39;)-&gt;delete(); // 删除id为5的用户数据 $User-&gt;where(&#39;status=0&#39;)-&gt;delete(); // 删除所有状态为0的用户数据 删除所有数据 避免错删数据，如果没有传入任何条件进行删除操作的话，不会执行删除操作 //无效 $User = M(&quot;User&quot;); // 实例化User对象 $User-&gt;delete(); // $User = M(&quot;User&quot;); // 实例化User对象 $User-&gt;where(&#39;1&#39;)-&gt;delete(); ActiveRecord 创建数据 $User = M(&quot;User&quot;); // 实例化User对象 // 然后直接给数据对象赋值 $User-&gt;name = &#39;ThinkPHP&#39;; $User-&gt;email = &#39;ThinkPHP@gmail.com&#39;; // 把数据对象添加到数据库 $User-&gt;add(); 查询 find()主键 $User = M(&quot;User&quot;); // 实例化User对象 // 查找id为8的用户数据 $User-&gt;find(8); 根据某个字段查询 $User = M(&quot;User&quot;); // 实例化User对象 $User-&gt;getByName(&quot;ThinkPHP&quot;); 查询数据集 //主键 $userList = $User-&gt;select(&#39;1,3,8&#39;); 更新记录 $User-&gt;find(1); // 查找主键为1的数据 $User-&gt;name = &#39;TOPThink&#39;; // 修改数据对象 $User-&gt;save(); // 保存当前数据对象 // 可以不查询就保存 $User-&gt;id = 1; $User-&gt;name = &#39;TOPThink&#39;; // 修改数据对象 $User-&gt;save(); // 保存当前数据对象 删除 $User-&gt;find(2); $User-&gt;delete(); // 删除当前的数据对象 //或者直接根据主键进行删除 $User-&gt;delete(8); // 删除主键为8的数据 $User-&gt;delete(&#39;5,6&#39;); // 删除主键为5、6的多个数据]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>thinkPhp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http技术]]></title>
    <url>%2Fpost%2Fa867c080.html</url>
    <content type="text"><![CDATA[HTTP API 认证授权术我们知道，HTTP是无状态的，所以，当我们需要获得用户是否在登录的状态时，我们需要检查用户的登录状态，一般来说，用户的登录成功后，服务器会发一个登录凭证（又被叫作Token），就像你去访问某个公司，在前台被认证过合法后，这个公司的前台会给你的一个访客卡一样，之后，你在这个公司内去到哪都用这个访客卡来开门，而不再校验你是哪一个人。在计算机的世界里，这个登录凭证的相关数据会放在两种地方，一个地方在用户端，以Cookie的方式（一般不会放在浏览器的Local Storage，因为这很容易出现登录凭证被XSS攻击），另一个地方是放在服务器端，又叫Session的方式（SessonID存于Cookie）。 但是，这个世界还是比较复杂的，除了用户访问，还有用户委托的第三方的应用，还有企业和企业间的调用，这里，我想把业内常用的一些 API认证技术相对系统地总结归纳一下，这样可以让大家更为全面的了解这些技术。 HTTP BasicHTTP Basic 是一个非常传统的API认证技术，也是一个比较简单的技术。这个技术也就是使用 username和 password 来进行登录。整个过程被定义在了 RFC 2617 中，也被描述在了 Wikipedia: Basic Access Authentication 词条中，同时也可以参看 MDN HTTP Authentication 其技术原理如下： 把 username和 password 做成 username:password 的样子（用冒号分隔） 进行Base64编码。Base64(&quot;username:password&quot;) 得到一个字符串（如：把 haoel:coolshell 进行base64 后可以得到 aGFvZW86Y29vbHNoZWxsCg ） 把 aGFvZW86Y29vbHNoZWxsCg放到HTTP头中 Authorization 字段中，形成 Authorization: Basic aGFvZW86Y29vbHNoZWxsCg，然后发送到服务端。 服务端如果没有在头里看到认证字段，则返回401错，以及一个个WWW-Authenticate: Basic Realm=&#39;HelloWorld&#39; 之类的头要求客户端进行认证。之后如果没有认证通过，则返回一个401错。如果服务端认证通过，那么会返回200。 我们可以看到，使用Base64的目的无非就是为了把一些特殊的字符给搞掉，这样就可以放在HTTP协议里传输了。而这种方式的问题最大的问题就是把用户名和口令放在网络上传，所以，一般要配合TLS/SSL的安全加密方式来使用。我们可以看到 JIRA Cloud 的API认证支持HTTP Basic 这样的方式。 但我们还是要知道，这种把用户名和密码同时放在公网上传输的方式有点不太好，因为Base64不是加密协议，而是编码协议，所以就算是有HTTPS作为安全保护，给人的感觉还是不放心。 Digest Access中文称“HTTP 摘要认证”，最初被定义在了 RFC 2069 文档中（后来被 RFC 2617 引入了一系列安全增强的选项；“保护质量”(qop)、随机数计数器由客户端增加、以及客户生成的随机数）。 其基本思路是，请求方把用户名口令和域做一个MD5 – MD5(username:realm:password) 然后传给服务器，这样就不会在网上传用户名和口令了，但是，因为用户名和口令基本不会变，所以，这个MD5的字符串也是比较固定的，因此，这个认证过程在其中加入了两个事，一个是 nonce 另一个是 qop 首先，调用方发起一个普通的HTTP请求。比如：GET /coolshell/admin/ HTTP/1.1 服务端自然不能认证能过，服务端返回401错误，并且在HTTP头里的 WWW-Authenticate 包含如下信息： WWW-Authenticate: Digest realm=&quot;testrealm@host.com&quot;, qop=&quot;auth,auth-int&quot;, nonce=&quot;dcd98b7102dd2f0e8b11d0f600bfb0c093&quot;, opaque=&quot;5ccc069c403ebaf9f0171e9517f40e41&quot; 其中的 nonce 为服务器端生成的随机数，然后，客户端做 HASH1=MD5(MD5(username:realm:password):nonce:cnonce) ，其中的 cnonce 为客户端生成的随机数，这样就可以使得整个MD5的结果是不一样的。 如果 qop 中包含了 auth ，那么还得做 HASH2=MD5(method:digestURI) 其中的 method 就是HTTP的请求方法（GET/POST…），digestURI 是请求的URL。 如果 qop 中包含了 auth-init ，那么，得做 HASH2=MD5(method:digestURI:MD5(entityBody)) 其中的 entityBody 就是HTTP请求的整个数据体。 然后，得到 response = MD5(HASH1:nonce:nonceCount:cnonce:qop:HASH2) 如果没有 qop则 response = MD5(HA1:nonce:HA2) 最后，我们的客户端对服务端发起如下请求—— 注意HTTP头的 Authorization: Digest ... GET /dir/index.html HTTP/1.0 Host: localhost Authorization: Digest username=&quot;Mufasa&quot;, realm=&quot;testrealm@host.com&quot;, nonce=&quot;dcd98b7102dd2f0e8b11d0f600bfb0c093&quot;, uri=&quot;%2Fcoolshell%2Fadmin&quot;, qop=auth, nc=00000001, cnonce=&quot;0a4f113b&quot;, response=&quot;6629fae49393a05397450978507c4ef1&quot;, opaque=&quot;5ccc069c403ebaf9f0171e9517f40e41&quot; 维基百科上的 Wikipedia: Digest access authentication 词条非常详细地描述了这个细节。 摘要认证这个方式会比之前的方式要好一些，因为没有在网上传递用户的密码，而只是把密码的MD5传送过去，相对会比较安全，而且，其并不需要是否TLS/SSL的安全链接。但是，别看这个算法这么复杂，最后你可以发现，整个过程其实关键是用户的password，这个password如果不够得杂，其实是可以被暴力破解的，而且，整个过程是非常容易受到中间人攻击——比如一个中间人告诉客户端需要的 Basic 的认证方式 或是 老旧签名认证方式（RFC2069）。 App Secret Key + HMAC先说HMAC技术，这个东西来自于MAC – Message Authentication Code，是一种用于给消息签名的技术，也就是说，我们怕消息在传递的过程中被人修改，所以，我们需要用对消息进行一个MAC算法，得到一个摘要字串，然后，接收方得到消息后，进行同样的计算，然后比较这个MAC字符串，如果一致，则表明没有被修改过（整个过程参看下图）。而HMAC – Hash-based Authenticsation Code，指的是利用Hash技术完成这一工作，比如：SHA-256算法。 （图片来自 Wikipedia – MAC 词条 ） 我们再来说App ID，这个东西跟验证没有关系，只是用来区分，是谁来调用API的，就像我们每个人的身份证一样，只是用来标注不同的人，不是用来做身份认证的。与前面的不同之处是，这里，我们需要用App ID 来映射一个用于加密的密钥，这样一来，我们就可以在服务器端进行相关的管理，我们可以生成若干个密钥对（AppID, AppSecret），并可以有更细粒度的操作权限管理。 把AppID和HMAC用于API认证，目前来说，玩得最好最专业的应该是AWS了，我们可以通过S3的API请求签名文档看到AWS是怎么玩的。整个过程还是非常复杂的，可以通过下面的图片流程看个大概。基本上来说，分成如下几个步骤： 把HTTP的请求（方法、URI、查询字串、头、签名头，body）打个包叫 CanonicalRequest，作个SHA-256的签名，然后再做一个base16的编码 把上面的这个签名和签名算法 AWS4-HMAC-SHA256、时间戳、Scop，再打一个包，叫 StringToSign。 准备签名，用 AWSSecretAccessKey来对日期签一个 DataKey，再用 DataKey 对要操作的Region签一个 DataRegionKey ，再对相关的服务签一个DataRegionServiceKey ，最后得到 SigningKey. 用第三步的 SigningKey来对第二步的 StringToSign 签名。 最后，发出HTTP Request时，在HTTP头的 Authorization字段中放入如下的信息： Authorization: AWS4-HMAC-SHA256 Credential=AKIDEXAMPLE/20150830/us-east-1/iam/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature=5d672d79c15b13162d9279b0855cfba6789a8edb4c82c400e06b5924a6f2b5d7 其中的 AKIDEXAMPLE 是 AWS Access Key ID， 也就是所谓的 AppID，服务器端会根据这个AppID来查相关的 Secret Access Key，然后再验证签名。如果，你对这个过程有点没看懂的话，你可以读一读这篇文章——《Amazon S3 Rest API with curl》这篇文章里有好些代码，代码应该是最有细节也是最准确的了。 这种认证的方式好处在于，AppID和AppSecretKey，是由服务器的系统开出的，所以，是可以被管理的，AWS的IAM就是相关的管理，其管理了用户、权限和其对应的AppID和AppSecretKey。但是不好的地方在于，这个东西没有标准 ，所以，各家的实现很不一致。比如： Acquia 的 HMAC，微信的签名算法 （这里，我们需要说明一下，微信的API没有遵循HTTP协议的标准，把认证信息放在HTTP 头的 Authorization 里，而是放在body里） JWT – JSON Web TokensJWT是一个比较标准的认证解决方案，这个技术在Java圈里应该用的是非常普遍的。JWT签名也是一种MAC（Message Authentication Code）的方法。JWT的签名流程一般是下面这个样子： 用户使用用户名和口令到认证服务器上请求认证。 认证服务器验证用户名和口令后，以服务器端生成JWT Token，这个token的生成过程如下： 认证服务器还会生成一个 Secret Key（密钥） 对JWT Header和 JWT Payload分别求Base64。在Payload可能包括了用户的抽象ID和的过期时间。 用密钥对JWT签名 HMAC-SHA256(SecertKey, Base64UrlEncode(JWT-Header)+&#39;.&#39;+Base64UrlEncode(JWT-Payload)); 然后把 base64(header).base64(payload).signature 作为 JWT token返回客户端。 客户端使用JWT Token向应用服务器发送相关的请求。这个JWT Token就像一个临时用户权证一样。 当应用服务器收到请求后： 应用服务会检查 JWT Token，确认签名是正确的。 然而，因为只有认证服务器有这个用户的Secret Key（密钥），所以，应用服务器得把JWT Token传给认证服务器。 认证服务器通过JWT Payload 解出用户的抽象ID，然后通过抽象ID查到登录时生成的Secret Key，然后再来检查一下签名。 认证服务器检查通过后，应用服务就可以认为这是合法请求了。 我们可以看以，上面的这个过程，是在认证服务器上为用户动态生成 Secret Key的，应用服务在验签的时候，需要到认证服务器上去签，这个过程增加了一些网络调用，所以，JWT除了支持HMAC-SHA256的算法外，还支持RSA的非对称加密的算法。 使用RSA非对称算法，在认证服务器这边放一个私钥，在应用服务器那边放一个公钥，认证服务器使用私钥加密，应用服务器使用公钥解密，这样一来，就不需要应用服务器向认证服务器请求了，但是，RSA是一个很慢的算法，所以，虽然你省了网络调用，但是却费了CPU，尤其是Header和Payload比较长的时候。所以，一种比较好的玩法是，如果我们把header 和 payload简单地做SHA256，这会很快，然后，我们用RSA加密这个SHA256出来的字符串，这样一来，RSA算法就比较快了，而我们也做到了使用RSA签名的目的。 最后，我们只需要使用一个机制在认证服务器和应用服务器之间定期地换一下公钥私钥对就好了。 这里强烈建议全文阅读 Anglar 大学的 《JSW：The Complete Guide to JSON Web Tokens》 OAuth 1.0OAuth也是一个API认证的协议，这个协议最初在2006年由Twitter的工程师在开发OpenID实现的时候和社交书签网站Ma.gnolia时发现，没有一种好的委托授权协议，后来在2007年成立了一个OAuth小组，知道这个消息后，Google员工也加入进来，并完善有善了这个协议，在2007年底发布草案，过一年后，在2008年将OAuth放进了IETF作进一步的标准化工作，最后在2010年4月，正式发布OAuth 1.0，即：RFC 5849 （这个RFC比起TCP的那些来说读起来还是很轻松的），不过，如果你想了解其前身的草案，可以读一下 OAuth Core 1.0 Revision A ，我在下面做个大概的描述。 根据RFC 5849，可以看到 OAuth 的出现，目的是为了，用户为了想使用一个第三方的网络打印服务来打印他在某网站上的照片，但是，用户不想把自己的用户名和口令交给那个第三方的网络打印服务，但又想让那个第三方的网络打印服务来访问自己的照片，为了解决这个授权的问题，OAuth这个协议就出来了。 这个协议有三个角色： User（照片所有者-用户） Consumer（第三方照片打印服务） Service Provider（照片存储服务） 这个协义有三个阶段： Consumer获取Request Token Service Provider 认证用户并授权Consumer Consumer获取Access Token调用API访问用户的照片 整个授权过程是这样的： Consumer（第三方照片打印服务）需要先上Service Provider获得开发的 Consumer Key 和 Consumer Secret 当 User 访问 Consumer 时，Consumer 向 Service Provide 发起请求请求Request Token （需要对HTTP请求签名） Service Provide 验明 Consumer 是注册过的第三方服务商后，返回 Request Token（oauth_token）和 Request Token Secret （oauth_token_secret） Consumer 收到 Request Token 后，使用HTTP GET 请求把 User 切到 Service Provide 的认证页上（其中带上Request Token），让用户输入他的用户和口令。 Service Provider 认证 User 成功后，跳回 Consumer，并返回 Request Token （oauth_token）和 Verification Code（oauth_verifier） 接下来就是签名请求，用Request Token 和 Verification Code 换取 Access Token （oauth_token）和 Access Token Secret (oauth_token_secret) 最后使用Access Token 访问用户授权访问的资源。 下图附上一个Yahoo!的流程图可以看到整个过程的相关细节。 因为上面这个流程有三方：User，Consumer 和 Service Provide，所以，又叫 3-legged flow，三脚流程。OAuth 1.0 也有不需要用户参与的，只有Consumer 和 Service Provider 的， 也就是 2-legged flow 两脚流程，其中省掉了用户认证的事。整个过程如下所示： Consumer（第三方照片打印服务）需要先上Service Provider获得开发的 Consumer Key 和 Consumer Secret Consumer 向 Service Provide 发起请求请求Request Token （需要对HTTP请求签名） Service Provide 验明 Consumer 是注册过的第三方服务商后，返回 Request Token（oauth_token）和 Request Token Secret （oauth_token_secret） Consumer 收到 Request Token 后，直接换取 Access Token （oauth_token）和 Access Token Secret (oauth_token_secret) 最后使用Access Token 访问用户授权访问的资源。 最后，再来说一说OAuth中的签名。 我们可以看到，有两个密钥，一个是Consumer注册Service Provider时由Provider颁发的 Consumer Secret，另一个是 Token Secret。 签名密钥就是由这两具密钥拼接而成的，其中用 &amp;作连接符。假设 Consumer Secret 为 j49sk3j29djd 而 Token Secret 为dh893hdasih9那个，签名密钥为：j49sk3j29djd&amp;dh893hdasih9 在请求Request/Access Token的时候需要对整个HTTP请求进行签名（使用HMAC-SHA1和HMAC-RSA1签名算法），请求头中需要包括一些OAuth需要的字段，如： Consumer Key ： 也就是所谓的AppID Token： Request Token 或 Access Token Signature Method ：签名算法比如：HMAC-SHA1 Timestamp：过期时间 Nonce：随机字符串 Call Back：回调URL 下图是整个签名的示意图： 图片还是比较直观的，我就不多解释了。 OAuth 2.0在前面，我们可以看到，从Digest Access， 到AppID+HMAC，再到JWT，再到OAuth 1.0，这些个API认证都是要向Client发一个密钥（或是用密码）然后用HASH或是RSA来签HTTP的请求，这其中有个主要的原因是，以前的HTTP是明文传输，所以，在传输过程中很容易被篡改，于是才搞出来一套的安全签名机制，所以，这些个认证的玩法是可以在HTTP明文协议下玩的。 这种使用签名方式大家可以看到是比较复杂的，所以，对于开发者来说，也是很不友好的，在组织签名的那些HTTP报文的时候，各种，URLEncode和Base64，还要对Query的参数进行排序，然后有的方法还要层层签名，非常容易出错，另外，这种认证的安全粒度比较粗，授权也比较单一，对于有终端用户参与的移动端来说也有点不够。所以，在2012年的时候，OAuth 2.0 的 RFC 6749 正式放出。 OAuth 2.0依赖于TLS/SSL的链路加密技术（HTTPS），完全放弃了签名的方式，认证服务器再也不返回什么 token secret 的密钥了，所以，OAuth 2.0是完全不同于1.0 的，也是不兼容的。目前，Facebook 的 Graph API 只支持OAuth 2.0协议，Google 和 Microsoft Azure 也支持Auth 2.0，国内的微信和支付宝也支持使用OAuth 2.0。 下面，我们来重点看一下OAuth 2.0的两个主要的Flow： 一个是Authorization Code Flow， 这个是 3 legged 的 一个是Client Credential Flow，这个是 2 legged 的。 Authorization Code FlowAuthorization Code 是最常使用的OAuth 2.0的授权许可类型，它适用于用户给第三方应用授权访问自己信息的场景。这个Flow也是OAuth 2.0四个Flow中我个人觉得最完整的一个Flow，其流程图如下所示。 下面是对这个流程的一个细节上的解释： 1）当用户（Resource Owner）访问第三方应用（Client）的时候，第三方应用会把用户带到认证服务器（Authorization Server）上去，主要请求的是 /authorize API，其中的请求方式如下所示。 https://login.authorization-server.com/authorize? client_id=6731de76-14a6-49ae-97bc-6eba6914391e &amp;response_type=code &amp;redirect_uri=http%3A%2F%2Fexample-client.com%2Fcallback%2F &amp;scope=read &amp;state=xcoiv98CoolShell3kch 其中： client_id为第三方应用的App ID response_type=code为告诉认证服务器，我要走Authorization Code Flow。 redirect_uri意思是我跳转回第三方应用的URL scope意是相关的权限 state 是一个随机的字符串，主要用于防CSRF攻击。 2）当Authorization Server收到这个URL请求后，其会通过 client_id来检查 redirect_uri和 scope是否合法，如果合法，则弹出一个页面，让用户授权（如果用户没有登录，则先让用户登录，登录完成后，出现授权访问页面）。 3）当用户授权同意访问以后，Authorization Server 会跳转回 Client ，并以其中加入一个 Authorization Code。 如下所示： https://example-client.com/callback? code=Yzk5ZDczMzRlNDEwYlrEqdFSBzjqfTG &amp;state=xcoiv98CoolShell3kch 我们可以看到， 请流动的链接是第 1）步中的 redirect_uri 其中的 state 的值也和第 1）步的 state一样。 4）接下来，Client 就可以使用 Authorization Code 获得 Access Token。其需要向 Authorization Server 发出如下请求。 POST /oauth/token HTTP/1.1 Host: authorization-server.com code=Yzk5ZDczMzRlNDEwYlrEqdFSBzjqfTG &amp;grant_type=code &amp;redirect_uri=https%3A%2F%2Fexample-client.com%2Fcallback%2F &amp;client_id=6731de76-14a6-49ae-97bc-6eba6914391e &amp;client_secret=JqQX2PNo9bpM0uEihUPzyrh 5）如果没什么问题，Authorization 会返回如下信息。 { &quot;access_token&quot;: &quot;iJKV1QiLCJhbGciOiJSUzI1NiI&quot;, &quot;refresh_token&quot;: &quot;1KaPlrEqdFSBzjqfTGAMxZGU&quot;, &quot;token_type&quot;: &quot;bearer&quot;, &quot;expires&quot;: 3600, &quot;id_token&quot;: &quot;eyJ0eXAiOiJKV1QiLCJhbGciO.eyJhdWQiOiIyZDRkM...&quot; } 其中， access_token就是访问请求令牌了 refresh_token用于刷新 access_token id_token 是JWT的token，其中一般会包含用户的OpenID 6）接下来就是用 Access Token 请求用户的资源了。 GET /v1/user/pictures Host: https://example.resource.com Authorization: Bearer iJKV1QiLCJhbGciOiJSUzI1NiI Client Credential FlowClient Credential 是一个简化版的API认证，主要是用于认证服务器到服务器的调用，也就是没有用户参与的的认证流程。下面是相关的流程图。 这个过程非常简单，本质上就是Client用自己的 client_id和 client_secret向Authorization Server 要一个 Access Token，然后使用Access Token访问相关的资源。 请求示例 POST /token HTTP/1.1 Host: server.example.com Content-Type: application/x-www-form-urlencoded grant_type=client_credentials &amp;client_id=czZCaGRSa3F0Mzpn &amp;client_secret=7Fjfp0ZBr1KtDRbnfVdmIw 返回示例 { &quot;access_token&quot;:&quot;MTQ0NjJkZmQ5OTM2NDE1ZTZjNGZmZjI3&quot;, &quot;token_type&quot;:&quot;bearer&quot;, &quot;expires_in&quot;:3600, &quot;refresh_token&quot;:&quot;IwOGYzYTlmM2YxOTQ5MGE3YmNmMDFkNTVk&quot;, &quot;scope&quot;:&quot;create&quot; } 这里，容我多扯一句，微信公从平台的开发文档中，使用了OAuth 2.0 的 Client Credentials的方式（参看文档“微信公众号获取access token”），我截了个图如下所谓。我们可以看到，微信公众号使用的是GET方式的请求，把AppID和AppSecret放在了URL中，虽然这也符合OAuth 2.0，但是并不好，因为大多数网关代理会把整个URI请求记到日志中。我们只要脑补一下腾讯的网关的Access Log，里面的日志一定会有很多的各个用户的AppID和AppSecret…… 小结讲了这么多，我们来小结一下（下面的小结可能会有点散） 两个概念和三个术语 区分两个概念：Authentication（认证） 和 Authorization （授权），前者是证明请求者是身份，就像身份证一样，后者是为了获得权限。身份是区别于别人的证明，而权限是证明自己的特权。Authentication为了证明操作的这个人就是他本人，需要提供密码、短信验证码，甚至人脸识别。Authorization 则是不需要在所有的请求都需要验人，是在经过Authorization后得到一个Token，这就是Authorization。就像护照和签证一样。 区分三个概念：编码Base64Encode、签名HMAC、加密RSA。编码是为了更的传输，等同于明文，签名是为了信息不能被篡改，加密是为了不让别人看到是什么信息。 明白一些初衷 使用复杂地HMAC哈希签名方式主要是应对当年没有TLS/SSL加密链路的情况。 JWT把 uid 放在 Token中目的是为了去掉状态，但不能让用户修改，所以需要签名。 OAuth 1.0区分了两个事，一个是第三方的Client，一个是真正的用户，其先拿Request Token，再换Access Token的方法主要是为了把第三方应用和用户区分开来。 用户的Password是用户自己设置的，复杂度不可控，服务端颁发的Serect会很复杂，但主要目的是为了容易管理，可以随时注销掉。 OAuth 协议有比所有认证协议有更为灵活完善的配置，如果使用AppID/AppSecret签名的方式，又需要做到可以有不同的权限和可以随时注销，那么你得开发一个像AWS的IAM这样的账号和密钥对管理的系统。 相关的注意事项 无论是哪种方式，我们都应该遵循HTTP的规范，把认证信息放在 Authorization HTTP 头中。 不要使用GET的方式在URL中放入secret之类的东西，因为很多proxy或gateway的软件会把整个URL记在Access Log文件中。 密钥Secret相当于Password，但他是用来加密的，最好不要在网络上传输，如果要传输，最好使用TLS/SSL的安全链路。 HMAC中无论是MD5还是SHA1/SHA2，其计算都是非常快的，RSA的非对称加密是比较耗CPU的，尤其是要加密的字符串很长的时候。 最好不要在程序中hard code 你的 Secret，因为在github上有很多黑客的软件在监视各种Secret，千万小心！这类的东西应该放在你的配置系统或是部署系统中，在程序启动时设置在配置文件或是环境变量中。 使用AppID/AppSecret，还是使用OAuth1.0a，还是OAuth2.0，还是使用JWT，我个人建议使用TLS/SSL下的OAuth 2.0。 密钥是需要被管理的，管理就是可以新增可以撤销，可以设置账户和相关的权限。最好密钥是可以被自动更换的。 认证授权服务器（Authorization Server）和应用服务器（App Server）最好分开。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql高性能优化]]></title>
    <url>%2Fpost%2Fdc4896e1.html</url>
    <content type="text"><![CDATA[优化概述计算机行业的优化，早期的时候基本上以空间换时间，因为那时候内存和磁盘不足，都想着解决空间不足的问题；现在空间很足了，考虑的跟多的是时间换空间，空间比较重要； 所以以下 的优化基本上都是在时间上的优化。 建表原则定长和变长相分离✔在mysql中， 若一张表里面不存在varchar、text以及其变形、blob以及其变形的字段的话，那么张这个表其实也叫静态表，即该表的row_format是fixed，就是说每条记录所占用的字节一样。其优点读取快（因为每一行的字节数是一样的，容易算出第N行的记录在磁盘张的位置），缺点浪费额外一部分空间。 若一张表里面存在varchar、text以及其变形、blob以及其变形的字段的话，那么张这个表其实也叫动态表，即该表的row_format是dynamic，就是说每条记录所占用的字节是动态的。其优点节省空间，缺点增加读取的时间开销。 所以，做搜索查询量大的表一般都以空间来换取时间，设计成静态表。 常用和不常用分离这样也可以加快访问速度； 添加冗余字段一对多需要统计的字段，不好统计，可以添加冗余字段，是反范式的；范式原子性要高，原子性越高的话表被拆的 越细，查询起来关联的越多，也就越麻烦； 列的选择类型优先级 整型 定长，没有国家地区字符集差别， date,time 定长，考虑时区时候，写sql不方便 enum 能起到约束的作用，内部使用整型来存储 char 定长，考虑到字符集和校对集 varchar 变长，考虑到字符集和校对集 blob,text 无法使用内存临时表，排序只能在磁盘上进行 够用就可以够用就可以，不要慷慨；大的字段，浪费内存，影响速度； 避免使用null不利于索引和查询 索引优化索引的原理索引是一种数据结构，如果没有索引就必须遍历查找，利用索引，mysql首先从索引文件中找，找到数据后再从磁盘上查找； 索引的作用： 提高查询的速度 提高排序的速度 因为btree索引树本身是有序的，左到有-&gt;小到大，右到左-&gt;大到小； 提高分组统计的速度 分组的时候，一般要先排序，然后再分组 btree第一层 2^0 = 1，第二层2^1 = 2，第32层2^32 = 42亿，最多查找32次即可查找到； 优点： 精准查询速度没有hash快，但是可以对范围查询进行优化 可以利用上前缀索引，比如列的值为helloword建立索引，xx=hello可以利用上索引 hash只能在memory表中使用，时间复杂度O(1)，表示不过多少数据一下就查找到；利用hash函数，直接算出一个地址，直接把数据存在磁盘上的那个地址上，一对一的映射； 缺点： 连续的id值，在磁盘上的位置却不是连续的，在磁盘中容易形成磁盘空洞； 无法对范围查询进行优化，比较适合精准查询 无法利用前缀索引 排序也无法优化，因为无法范围优化 必须回行，也就是说必须回到数据文件所在的数据行 索引的误区 为where条件里的所有列都建立索引，因为独立索引同时只能用上一个，所以多个条件建立联合索引比较适合； 在多列上建立索引之后，查询哪个列，索引都发挥作用是错误的，多列索引需要满足左前缀原则。 例如，index(a,b,c)为例，针对查询，对group by 和 order by 只要保持顺序即可，前面断掉没关系(需要进一步验证)； where a=3，是，只使用了a列 where a=3 and b=5，是，使用了a，b列 where a=3 and b=5 and c=4，是，使用了a，b，c列 where b=3 或者where c=4，否 where a =3 and c=4，a列发生作用，c列不可以 where a=3 and b&gt;10 and c=7，a列发生作用，b列发生作用，c列没有 where a=3 and c like &#39;hello%&#39; and c=7，a列发生作用，b列发生作用，c列没有 where a=3 and c=4 and b=3，使用了a,b,c三列， where a=3 order by c，a列发挥查询作用，c列发挥排序作用 where b=3 group by c，c列发挥分组作用 联合索引要有严格顺序要求，建立三个列索引，就好比三块木板拼接形成的独木桥，必须严格的按顺序走下去才可以都使用到索引，跳过一块（比如where b=3 ）或者半块（比如where a=3 and b&gt;10 and c=7）木板都导致后面的索引失效； 如果where里有表达，或者函数，也将导致该列索引利用不上，因为没有建立该列的索引，除非不需要回行，索引覆盖的话查询还是用不上，但是获取数据的话会用的上； 如何建立索引首先需要观察实际业务，比如商城，一个都是先搜索分类，然后再搜索品牌，最后搜索价格，所以要index(分类，品牌，价格)建立索引，不要一上来就给分类，品牌，和价格分别建立索引，将会导致品牌和价格的索引失效； 多列索引： 一看频率 二看顺序 聚簇索引针对inodb引擎，主键查询的时候不需要回行去数据，读取速度比较快；次索引指向对主键的引用，然后再主键索引上聚簇，不然的话每个索引都聚簇的话，数据重复太多； 如果有text(3000)这样的字段，对查询速度的影响也挺大的； 缺点： 添加数据的时候，频繁的页分裂，带着沉重的数据，拼来拼去，速度比较慢；但是对固态硬盘和内存是随机读写，不像机械硬盘需要转到某个位置，所以页分裂的影响也不是很大； 非聚簇索引针对myisam引擎，需要回行查找数据； 索引覆盖如果建立index(id,name)联合索引，然后select id,name，这时候不需要回行，在索引树上都可以找到数据，explain的，在extra那边显示的是using index，速度极快 理想索引查询频繁区分度高比如性别这种就没有必要了； 索引的长度就像目录别太长； 覆盖常用字段sql语句优化总体的原则，不查(比如论坛会员数，有时候没必要精确，可以不差，写死每天多少个)，少查，走索引查询或者索引分组排序，甚至索引覆盖； explain 列名 说明 id 序号，如果explain多个select，就有1，2…多个编号，每个select是一个行结果 select_type 查询类型 table 哪张表 type All..，扫描的范围 possible_keys 可能使用到的键名 key 真正用到的键名 key_len 键用到多长 ref 引用，两表联查的时候又没引用关系， rows 估计下，本次要查出多少行 extra 额外的一些信息 select_type// 不含有子查询，则是simple select id from t; // 非from子查询，第一条是primary，第二条则是subquery select id from t where id in (select id from t) as t1 // from类型子查询，第一条是primary，第二条则是derived select id from (select id from t) as t1 // 联合查询，第一条是primary，第二条是union，第三条是union result select id from t union select id from t table// 1、实际的表名t select id from t; //2、实际的表名或者别名，tmp select id from t as tmp; //3、derived，派生表，实际不存在，放在内存中的，比如外层select select id from t where id in (select id from t) as t1 //4、null，没有from的 select 1 union select 2 possible_keys可能用到的索引，但是最终只能用到一个索引； key最终用到的索引 key_len使用到索引的最大长度，如果是独立索引则是该列的字节，如果是联合索引则是索引列和； type在优化的时候比较重要； All，扫描所有的数据，相当于data_all，where没有索引的列就会是这个； index，扫描所有的索引节点，相当于index_all，会比All好一点; 索引覆盖的查询情况下，能利用上索引数据，但是利用不上索引查找，必须全索引查找 // where是表达式，索引查找利用不上，但是goods_id索引覆盖 explain select goods_id from goods where goods_id + 1 = 20; 利用索引排序 // type是All，因为走索引然后回行，还比较慢，干脆直接All了 explain select * from goods order by goods_id desc; //type是index，可以索引覆盖快一点 explain select goods_id from goods order by goods_id desc; range //type是range，btree索引适合做范围查询，树右边的大于，树左边的小于 explain select goods_id from goods where goods_id &gt; 100; ref 引用的意思，索引找到并且引用到多行 //type是range，一个分类有多行 explain select goods_id from goods where cat_id = 2; eqref 引用的意思，索引找到并且引用到1行，速度快 constant,system,null constant ，系统知道在哪个位置，不需要查，explain select goods_id from goods where goods_id = 2;，主键等于查询 null，select count(*) from goods; ref引用，关联查询时候，两个关联表的关联字段 rows估计要扫多少行 extra using index，用到索引覆盖，不需要回行 using where，光靠索引定位不了，需要where帮忙判断一下 using temporary，用上 了临时表，group by不走索引时候，需要先排序生成排序后的临时表，然后再分组，如果直接索引列进行分组的话，因为索引本身是有序的速度 也比较快； using filesort，排序 注意： 如果select的字段有text类型的大字段，using temporary和using filesort时候，如果发生再磁盘上，而不是再内存中，速度更慢，可以通过]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php开发]]></title>
    <url>%2Fpost%2F1311505c.html</url>
    <content type="text"><![CDATA[面向对象面向对象的方式，可以使用类和继承轻松的描述现实生活中的情况，编写出的代码也比较容易理解和灵活； 访问修饰符通过访问修饰符，来控制在制定范围内可以使用 public 作用域【类内外（对象）】 protected 作用域【本类，和父类】 private 作用域【本类】 new关键字和构造函数__construct()，通常用于自动执行许多初始化的操作，例如属性的初始化；可以接受参数，在new的时候传递参数；在new的是返回的是指向对象的句柄（对象的id）； 析构函数__destruct()，用于注销一个类，当一个类被注销的时候被调用，php会在请求结束之后确保所有的资源都被释放，所有析构函数在php当中显得不是很重要； 但是在执行一些事件的时候还是有用的，清楚资源对象注销的时候记录一些日志信息； 接口因为在对象中经常要范文其他对象的功能，就叫对象的接口，一个类可以实现多个接口；php选择了接口来实现类似C++中的多重继承； 在程序设计里有一个面向接口的开发，服务端（往往是sdk，或者java里jar包，看不到源码，只看到到接口，客户端根据这个接口可以调用，不像php直接看到源码）和客户端都面向接口，无论开发者和调用者，都对接口负责； 接口总是被认为是public的，因此在定义的使用不能给权限修饰符； 接口支持继承； instanceof操作符语言级别检查对象是否是属于某个类，检查对象“是一（is a）”的关系，比如，猫是一种动物； Final关键字可以标记类和方法，限制其不能被重载 __toString()方法如果打印对象的时候，将会执行这个方法 __autoload()clone关键字new对象是返回指向对象的句柄，如果直接复制，则是赋值句柄，所有还是同一个对象，因此需要克隆，__clone()方法将自动指向； 异常处理通过异常有许多好处：不需要许多if来判断可能的异常，可以减少许多的代码； 多态哺乳动物都能发声音，但是每种哺乳动物发出声音的状态是不一样的，有多种状态，php可以实现这一问题； 多态可以减少if等流程控制语句，提高代码的健壮性； Abstract class Animal { Abstract public function makeSound() } class Cat extends Animal { public function makeSound() { print &#39;喵&#39;; } } class Dog extends Animal { public function makeSound() { print &#39;旺&#39;; } } function printTheRightSound() { //通过继承实现是一关系，这样就不需要很多个流程控制语句，扩展的时候也不需要改代码 if ($obj instanceof Animal) { $obj-&gt;makeSound(); } else { print &#39;error&#39;; } } printTheRightSound(new Cat()); printTheRightSound(new Dog()); 类中的常量 类中定义的常量，不能用表达式，必须在编译开始就要被确定了 可以使用类来引用 最常用的地方是用在定义枚举元素； 静态方法 不需要实例化就可以调用 不支持$this调用，因为它没有绑定任何对象 使用类名来调用 静态成员（属性）使用类名来调用 应用： 单例模式 static private $instance = null; static public function getInstance() { if (self::$instance == null) { self::$instance = new self(); } return self::$instance; } //调用时候，类名::getInstance()，这样就能确保只会实例化一次，在框架的组件实例化基本都是单例的 常量标签使用 //单据状态 const ORDER_STATUS_CANCEL = 1; static public $orderStatusLabel = [ self::ORDER_STATUS_CANCEL=&gt;&#39;作废&#39; ]; parent::和self::是两种类名的保留字，self指向当前类，通常用于访问静态成员、方法和变量；parent::指向父类，可以访问父类的方法，成员和常量，最好不要直接用父类的名称来访问父类的名称，parent可以方便更改类的层次； 抽象类抽象类不允许被实例化，必须通过继承了它的子类来实例化； 应用： 在yii框架中，一个应用可能包含web应用和控制台应用，所有可以把Base类Application类声明为抽象类，因为实例化这个基础类没什么意义，所有可以创建一个web Application类和Console Application类来继承Base Application，然后实例化各自的子类，这样一个子类就是一个具体的实例，就有意义； 抽象方法想保留一些方法给继承类来实现，因为这些方法只有在继承类中才有具体的意义； abstract class MyBaseClass { //本身类必须是抽象类，为了在子类中再去定义这个方法，本身还不确定内容 abstract function dispaly() } 对象类型提示function expectMyClass(MyClass $obj) { //可以对函数参数进行对象类型提示，如果类型不正确则会报错 } 支持连续引用方法返回的对象$obj-&gt;method()-&gt;method2(); 重载PHP所提供的重载（overloading）是指动态地创建类属性和方法 属性和方法的重载可以通过代理函数（魔术方法）来实现； 数组语法访问重载可以通过实现ArrayAccess接口来实现； 迭代器任何实现Traversable接口的类都可以使用foreach结构遍历 设计模式单例模式主要目的就是为了避免混乱，好管理；例如一个系统中如果有多个redis对象组件，就容易混乱 如何实现： Class Emperor { static private $instance = null; //1把构造函数设置为私有的，外部无法调用，内部可以调用 final private function __construct() { } //2禁止被克隆 final private function __clone() { } //3创建类 static public function getInstance() { if (self::$instance == null) { self::$instance = new self(); } return self::$instance; } } 优点： 内存中只有一个实例，减少内存的开支 不需要频繁的创建和销毁，可以减少系统性能的开销 可以避免对资源的多重占用，例如一个写操作，单例不会对资源文件同时写操作，也可以避免混乱 可以在系统中设置全局的访问点，优化和共享资源访问； 简单工厂模式主要目的是在面向接口开发中，服务端不喜欢让客户端知道太多代码信息，比如类名，所以可以给个工厂方法即可； /** * 服务端或者其他团队在开发一个数据库类包的时候，有两个要求： * 1、不希望客户端知道具体的类名 * 2、只暴露interface接口 */ interface db { function conn(); } class dbmysql implements db { public function connc() { // } } class dbsqlite implements db { public function connc() { // } } class Factory { public static function crateDB($type) { if ($type == &#39;mysql&#39;) { return new dbmysql(); } elseif ($type == &#39;sqlite&#39;) { return new dbsqlite(); } else { } } } // 这样客户端就可以不知道类名了，只开发一个Factory::crateDB()方法即可 $mysql = Factory::crateDB(&#39;mysql&#39;); 但是简单工厂模式有个缺点，就是违反开闭原则，增加其他数据库的时候，需要修改工厂，所以使用抽象工厂模式； 工厂方法模式主要目的在满足简单工厂方法的时候，还可以满足开闭原则，同时容易扩展； /** * 服务端或者其他团队在开发一个数据库类包的时候，有两个要求： * 1、不希望客户端知道具体的类名 * 2、只暴露interface接口 */ interface db { function conn(); } class dbmysql implements db { public function connc() { // } } class dbsqlite implements db { public function connc() { // } } interface Factory { function createDb(); } class mysqlFactory implements Factory { public static function crateDB($type) { return new dbmysql(); } } class sqliteFactory implements Factory { public static function crateDB($type) { return new dbsqlite(); } } //这样新增加其他扩展的时候，不需要修改工厂方法 $db = mysqlFactory::crateDB(); $db-&gt;conn(); $db = sqliteFactory::crateDB(); $db-&gt;conn(); 模板方法模式建造者模式代理模式原型模式中介者模式命令模式责任链模式装饰模式策略模式迭代器模式组合模式观察者模式主要目的为了是解耦，客户端和服务器端完成了解耦，把逻辑都写在观察者本身，需要在被观察这边添加太多观察者的逻辑；容易扩展，添加多个观察者不需要改太多代码； &lt;select&gt; &lt;option&gt;被观察者1&lt;/option&gt; &lt;option&gt;被观察者2&lt;/option&gt; &lt;/select&gt; &lt;div title=&quot;观察者1&quot;&gt;&lt;/div&gt; &lt;span title=&quot;观察者2&quot;&gt;&lt;/span&gt; &lt;script&gt; //sel对象是被观察则 var sel = $(select); sel.obServers={}; sel.attatch = function (key,obj){ sel.obServers[key] = obj;//添加观察者 } sel.notify = function(key){ for (var key in this.observers) { this.obServers[key].update(this); } } //我有变化时候，要通知这些观察者 $(select).change(function(){ this.notify(); }); //观察者1 var observer1 = $(&#39;div&#39;); observer.update = function (){ } sel.attatch(&#39;div&#39;,observer); //观察者2 var observer2 = $(&#39;span&#39;); observer.update = function (){ } sel.attatch(&#39;div&#39;,observer); &lt;/script&gt; 门面模式备忘录模式访问者模式状态模式解释器模式享元模式桥梁模式设计原则单一职责原则里式替换原则依赖倒置原则接口隔离原则迪米特法则开闭原则对于修改是封闭的，对扩展是开放的；因为修改源代码重新编译需要太多的时间 映射也就是Reflection，也叫做内观，可以实时的收集脚本的信息，比如类的信息，方法的信息，注释的信息等； 基础语言嵌入html可以将php代码嵌入html中，可以在代码写在标签当中。 &lt;?php echo &#39;hello word&#39;; ?&gt; //php.ini开启短标签的情况下short_open_tat = true &lt;? echo &#39;hello word&#39;; ?&gt; 注释c语言的方式 /** * c风格注释 * 可以跨越多行 * 直到关闭标记 */ c++方式 //c++注释，行末结束 shell方式 # 行末结束 变量以$开头，可以包含字母，数字，下划线，并且不能以数字开头； 作用域不支持全局变量，除非一些预定义的变量； 函数中的变量，只有在函数内生效，函数外面访问不了，且函数销毁，变量也就随之销毁了； 在脚本中的变量不是全局变量，在函数内部是无法范围的，但是可以使用$GLOBALS[]来访问； 变量的间接引用允许变量的名称也是变量 $name = &quot;zhangsang&quot;; $$name = &quot;注册用户&quot;; print $zhangsang; 管理变量有三种管理变量的语言结构； isset() 支持判断变量isset($var)，数组元素isset($arr[&#39;key&#39;])，对象属性isset($obj-&gt;property)是否存在或者为null，可以接收多个参数； unnset() 用于取消变量的定义，如果变量没有被引用，则释放内存空间； empty() 检查变量是否被设置，或者是否为false； 超全局变量$_GET[]，$_POST[]，$_ENV[]，$_SERVER[]，$_COOKIE[]，$GLOBALS[] 数据的基本类型整型 浮点型 字符串 布尔 Null 数组 常量 运算符一元运算符否定运算符，取非!等一个操作数的； 递增，递减运算符,++，–等 类型转换运算符，(int)等 错误抑制运算符，@ 二元运算符算术元素符 串联运算符(.) 赋值运算符，引用赋值运算符（其实就是创建一个别名，就是同一个变量） 比较运算符 逻辑运算符 位运算符 三元运算符？： 控制结构条件控制结构if，switch等 循环控制结构foreach，for，while等 代码包控制结构include等 函数用户定义的函数函数的作用域默认在函数内部是不能直接访问到函数外面的变量，但是可以在$GLOBALS[]变量，或者global 声明来访问； function func () { $var = 2; } $var = 1; func(); print $var;//将打印出1，函数内的$var不是外部的那个变量 function func () { $GLOBALS[&#39;var&#39;] = 2;//可以访问到脚本的变量 } $var = 1; func(); print $var;//将打印出2 function func () { //把变量引入到函数中去，但是不推荐 //因为引用赋值将导致运行混乱，不支持unset()等 global $var; } $var = 1; func(); print $var;//将打印出2 通过值返回数据返回值被复制并返回给调用函数 function getGlobalVarVal($name) { return $GLOBALS[$name]; } $num = 10; $val = getGlobalVarVal(&#39;num&#39;); print $val;//返回10，不会影响全局变量$num，因为是通过值返回的，是赋值 通过引用返回数据function &amp;getGlobalVarVal($name) { return $GLOBALS[$name];//以引用的方式返回值 } $num = 10; $val = getGlobalVarVal(&#39;num&#39;); $val = 20; print $val;//返回20， 函数的参数值传递 参数可以是任何合法的表达式； function pow ($x,$y) { ... } pow(2*4,$c);//参数可以是表达式 引用传递 &amp;符号告诉php，这个一个引用传递 function square(&amp;$n) { $n = $n*$n; } $number = 4; square($number); print $number;//16 默认参数静态变量php支持声明函数本地的变量为静态变量，可以保存数值函数结束不被释放，初始值在第一次static声明的时候发生； 回调函数 静态方法的方式 匿名函数的方式 函数名称的方式 对象的方法 swoole服务器tcp#查看端口 netstat -anp | grep 9501 #可以使用telnet作为客户端连接tcp服务 telnet 127.0.0.1 9501 udp客户端tcpudpHttp服务http协议也是基于tcp的协议； 优点：不需要走php-fpm管理fast-cgi管理 websocket服务基于tcp的全双工协议 swoole task适合处理一些耗时的任务 异步io定时器毫秒级别定时器，crontab最小只能1分钟 异步文件io可以异步读写文件 异步mysql 异步连接mysql 异步查询等 异步redis进程管理类似pntcl进程管理，在搭建类似gitlab的平台时候需要 创建子进程 执行外部的经常 内存操作可以在内存中申请一个内存空间来存东西，设置数据获取数据； 协程同步的代码来编写异步的效果和性能，不需要太多的回调；各个进程之间协同合作；]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh使用]]></title>
    <url>%2Fpost%2Ff4bf1653.html</url>
    <content type="text"><![CDATA[常见问题ssh:Permissions 0644 for ‘/root/.ssh/id_rsa’ are too open 最近，用ssh连接github时，突然提示“Permissions 0644 for ‘/root/.ssh/id_rsa’ are too open”，并且断开连接。 仔细阅读了一下ssh文档和这句提示，大概的意思时ssh的私有密钥的权限开放尺度太大了，可以供人随意欣赏了，ssh自身的策略关闭了ssh。 解决方案：将权限由0644降低为0600 chmod 0600 ~/.ssh/id_rsa]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaraDock新手使用教程]]></title>
    <url>%2Fpost%2F8c17f486.html</url>
    <content type="text"><![CDATA[laradock开发环境 laradock包括预打包的Docker镜像，所有这些都经过预先配置，可提供出色的PHP开发环境。 Laradock在Laravel社区中是众所周知的，因为该项目始于专注于在Docker上运行Laravel项目。后来由于PHP社区的大量采用，它开始支持其他PHP项目，如Symfony，CodeIgniter，WordPress，Drupal …… 软件下载laradock在您的计算机上的任何位置克隆此存储库 git clone https://github.com/Laradock/laradock.git 下载项目 composer create-project --prefer-dist laravel/laravel hdcms ... 项目安装安装 Laravel 安装程序 composer global require laravel/installer 创建软链接 sudo ln -s $HOME/.config/composer/vendor/bin/laravel /usr/bin/laravel # 或在 .zshrc 中添加 alias laravel=/Users/hd/.composer/vendor/bin/laravel 创建项目 laravel new houdunren # 如果不能使用 new 方式创建也可以使用以下方式 composer create-project --prefer-dist laravel/laravel houdunren 目录结构最终目录结构如下 + laradock + hdcms + houdunren 软件配置重命名env-example为.env，.env 是laradock的配置文件。 cp env-example .env 容器构建当修改了配置项后需要对镜像重新编译 重新编译Mysql docker-compose build mysql 重新编译所有镜像并禁用缓存 docker-compose build PHP更改版本php版本 修改.env配置文件版本为7.3 PHP_VERSION=7.3 最后重建镜像 docker-compose build php-fpm PHP-CLI版本 修改.env配置文件PHP_VERSION为7.3。 PHP_VERSION=7.3 最后重建图像，执行php-cli是在workspace镜像的容器中所以需要重新构建workspace docker-compose build workspace 在virtualbox下访问共享文件夹的权限问题no permission的问题，不然会报File not found错误： 以下是解决方法： 在 container 下创建一个叫做vboxsf的 group： groupadd vboxsf 修改这个 group 的 id 为994（具体要看）：vim /etc/group,在debian系统中，如果说vim命令不存在，则执行apt-get update,然后apt-get install vim 把 www-data 这个用户加入到vboxsf中：usermod -a -G vboxsf www-data 重启 php-fpm 问题： install failed ERROR: Service &#39;php-fpm&#39; failed to build: The command &#39;/bin/sh -c if [ ${INSTALL_IMAGEMAGICK} = true ]; then apt-get install -y libmagickwand-dev imagemagick &amp;&amp; pecl install imagick &amp;&amp; docker-php-ext-enable imagick ;fi&#39; returned a non-zero code: 1 此时开启VPN重新构建既可以 PhpMyAdminphpmyadmin使用该docker-compose up命令运行phpMyAdmin # use with mysql docker-compose up -d mysql phpmyadmin 打开浏览器并访问端口8080上的localhost ： http://localhost:8080，登录信息如下 host: mysql user: root password: root Nginx项目要与 laradock 同级，系统会自动将目录同步到服务窗口，下面是向军大叔的目录结构： - laradock - hdcms - houdunren 站点配置站点配置需要在 laradock/nginx/sites 目录中复制文件。 cp laravel.conf.example hdcms.conf 内容如下 ... server_name hdcms.test; root /var/www/hdcms/public; ... 再复制创建houdunren.conf，内容如下 ... server_name houdunren.test; root /var/www/hdcms/public; ... 如果已经启动过容器需要执行以下命令 docker-compose build nginx docker-compose restart nginx 在virtualbox下访问共享文件夹的权限问题no permission的问题，不然会报404错误： 以下是解决方法： 在 container 下创建一个叫做vboxsf的 group： groupadd vboxsf 修改这个 group 的 id 为994（具体要看）：vim /etc/group 把 www-data 这个用户加入到vboxsf中：usermod -a -G vboxsf www-data，在alpine系统中，这个命令默认是不存在的，要执行apk --no-cache add shadow安装 重启 nginx 域名解析设置宿主电脑 /etc/hosts 文件内容 127.0.0.1 hdcms.test 127.0.0.1 houdunren.test Mysql更改版本默认情况下使用MySQL 8.0运行。您可能更喜欢使用其他版本，如：5.5,5.6,5.7,8.0或最新版本。有关更多信息，请参阅https://store.docker.com/images/mysql。 修改.env laradock配置文件 MYSQL_VERSION=5.7.26 重新编译 docker-compose build mysql 如果已经运行则重新启动 docker-compose restart mysql 访问在laravel项目中设置主机 DB_HOST=mysql 可以使用 sequel Pro 等客户端进行连接，默认连接帐号如下： host: 127.0.0.1 user: root password: root Redis打开Laravel的.env文件并将其设置REDIS_HOST为redis REDIS_HOST=redis 启用Redis缓存和/或会话管理。还从.env文件集CACHE_DRIVER，并SESSION_DRIVER于redis而不是默认的file。 CACHE_DRIVER=redis SESSION_DRIVER=redis 最后确保通过Composer安装了predis/predis软件包： composer require predis/predis 您可以使用以下代码从Laravel手动测试它： \Cache::store(&#39;redis&#39;)-&gt;put(&#39;app&#39;, &#39;hdcms&#39;, 10); workspaceworspace容器主要用来管理项目的。例如：执行一些cli的命令、php artisan、composer、php –version。 docker-compose exec --user=laradock workspace bash php artisan migrate 运行项目运行你的容器： docker-compose up -d nginx mysql phpmyadmin redis workspace 下载镜像过程非常慢，要耐心等待。查看 houdunren.com 相关docker文档配置加速器可提升下载速度。 打开浏览器并访问localhost : http://hdcms.test. That&#39;s it! enjoy :) 容器管理查看此项目容器(在项目的laradocker目录执行) docker-compose ps 停止运行的所有容器 docker-compose stop 删除所有服务窗口 docker-compose down 在virtualbox中使用 首先设置共享目录，见virtualbox的教程篇 然后进入虚拟机系统，添加用户组，这个不懂的是不是必须的 创建www-data用户 然后把www-data用户加入vboxsf 组：sudo usermod -a -G vboxsf yourusernanme #voboxsf组ID为994，下有root和www-data（docker默认运行的用户）用户 vboxsf:x:994:root,www-data www-data:x:1000: 然后进入容器中，以下是必须的 在 container 下创建一个叫做vboxsf的 group： groupadd vboxsf 修改这个 group 的 id 为994（具体要看宿主机的vboxsf组的id，因为virtualboxd的voboxsf组目录无法修改文件权限和组，所有只能加入）：vim /etc/group 把 www-data 这个用户加入到vboxsf中：usermod -a -G vboxsf www-data 重启 nginx 暴露2375端口在/usr/lib/systemd/system/docker.service，配置远程访问。 主要是在[Service]这个部分，加上下面两个参数 # vim /usr/lib/systemd/system/docker.service [Service] ExecStart= ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock 重启 Copysystemctl daemon-reload systemctl restart docker 基于virtualbox的linux下phpStorm xdebug调试参考：https://www.m-finder.com/2019/03/08/laradock-xdebug/ 编辑 .env 配置文件： WORKSPACE_INSTALL_XDEBUG=true PHP_FPM_INSTALL_XDEBUG=true phpinfo()里没有xdebug扩展，配置.env文件无效，直接进入容器： pecl install xdebug docker-php-ext-enable xdebug phpstorm，添加 php设置： options内容如下 -dxdebug.remote_host=docker.for.win.localhost -dxdebug.remote_enable=1 -dxdebug.remote_port=9000 -dxdebug.remote_mode=req phpstorm，添加 serrver设置： phpstorm，添加 remote_debug设置： 在win10docker下xdebuglaradock中php-fpm 的xdebug.ini配置修改 laradock/php-fpm/xdebug.ini 如果是Windows系统则改为 xdebug.remote_host=docker.for.win.localhost xdebug.remote_connect_back=0 如果是OSX系统则改为 xdebug.remote_host=docker.for.mac.localhost xdebug.remote_connect_back=0 xdebug.ini文件中其他参数不用动xdebug.remote_host参数设置的是xdebug服务器的地址，这里实际上是phpstorm的网络地址xdebug.remote_connect_back这个参数如果为1表示根据请求来源“remote_host”，来发起调试，在docker环境下有网络nat所以不会成功，这个参数的改为0 修改完成后执行docker-compose build workspace php-fpm 重新编译 phpstorm的配置 server配置File&gt; Settings&gt; Languages &amp; Frameworks &gt; PHPDebug 默认参数可以不动Servers 中Name： laradock Host：你的网址 Port：80 Debugger：Xdebug勾选 “Use path mappings” 把项目目录和laradock中 /var/www/你的项目 进行目录映射 phpstorm的xdebug配置不在累述，可以参见laradock http://laradock.io/documentation/#install-xdebug debug配置Run&gt; Edit Configurations 访问laravel.test查看debug效果 hyper-v下的问题hyper-v有些保留的端口，可能冲突（比如workspace一直端口被占用的问题），如果冲突可以修改： # 查看哪些端口被保留 netsh interface ipv4 show excludedportrange protocol=tcp # 可以搜索主机的端口 netstat -aon|findstr &quot;80&quot; 安装时候，需要代理，不然容易安装不成功]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>laradock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[virtualBox安装centos7.2]]></title>
    <url>%2Fpost%2F4949a8f8.html</url>
    <content type="text"><![CDATA[基于virtualBox的开发环境搭建 命令操作启动Headless模式VirtualBox虚拟机有一种模式为headless模式，即无显示模式： VBoxManage startvm &lt;uuid&gt;|&lt;name&gt; [--type gui|sdl|headless] 假设我们的虚拟机叫做nenew，我们像启动headless模式的虚拟机的化，我们可以执行下列命令： vboxmanage startvm nenew --type headless 上面的这条命令可以运行headless模式的虚拟机。在运行完命令后虚拟机应该已经后台运行了，并出现下行提示： Waiting for the VM to power on… VM has been successfully started. 虚拟机已经后台运行了，可使用下列命令对其进行关闭重庆等操作。 虚拟机状态控制VBoxManage controlvm &lt;uuid&gt;|&lt;name&gt; pause|resume|reset|poweroff|savestate| 例如关闭刚才启动的headless虚拟机nenew我们可以用下面命令来完成 vboxmanage controlvm nenew poweroff 共享目录设定进入centos系统： 一、安装基本依赖，如果没有这些将无法安装增强功能 更新kernel yum update kernel -y 安装kernel-headers, kernel-devel 和其他要求的包 #安装完之后切记要重启虚拟机，不然无法安装成功 yum install kernel-headers kernel-devel gcc make -y ​ 3.重启系统，确保加载新的kernel init 6 二、安装增强功能 在设备选项里直接点安装增强功能会报错无法加载，应该是VboxguestAdditions.iso被占用的原因。所有要把安装目录下的VboxguestAdditions.iso复制到其他位置，然后执行下面的分配光驱方式来挂载安装即可 1.挂载镜像到系统 2.执行挂载命令，将虚拟光盘挂在到 /mnt/cdrom，如果没有cdrom目录，则先创建之 mkdir /mnt/cdrom mount /dev/cdrom /mnt/cdrom 复制脚本到/tmp目录下 cd /mnt/cdrom cp VBoxLinuxAdditions.run /tmp cd /tmp chmod 777 VBoxLinuxAdditions.run 4.执行安装，如果没有第一步的内容，可能将无法安装成功 ./VBoxLinuxAdditions.run 最后输出VirtualBox Guest Additions: Running kernel modules will not be replaced until the system is restarted的话表示安装成功，可以挂载共享目录了 三、添加挂载目录 上面的操作也可以用命令来实现 #删除 VBoxManage sharedfolder remove centos --name data #添加名称为www的共享目录 vboxmanage sharedfolder add centos --name www --hostpath F:\www --automount 手动挂载 #之后即可看到共享目录了 mount -t vboxsf www(主机上的分享文件夹的名称) /var/www(虚拟机系统里的文件名称) 桥接网络virtualbox设置桥接模式联网，==注意：选择电脑正在使用的网卡！！！共享同一张网卡== 使用命令查看虚拟机运行的网卡配置，并且按照下文修改配置 # ifconfig / ip addr # cd /etc/sysconfig/network-scripts/ # vi ifcfg-enp0s3 TYPE=Ethernet BOOTPROTO=dhcp ############改动部分开始############ #动态IP #BOOTPROTO=&quot;dhcp&quot; #静态IP设置 BOOTPROTO=&quot;static&quot; IPADDR=192.168.1.222 #静态ip要符合网关内的 NETMASK=255.255.255.0 #查看物理机的掩码 GATEWAY=192.168.1.1 #物理机的网关 DNS1=114.114.114.114 ############改动部分结束############ DEFROUTE=yes PEERDNS=yes PEERROUTES=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_PEERDNS=yes IPV6_PEERROUTES=yes IPV6_FAILURE_FATAL=no NAME=enp0s3 UUID=d592be2d-d56f-4b37-887c-448cd9e8b696 DEVICE=enp0s3 ############改动部分开始############ #ONBOOT=no ONBOOT=yes ############改动部分结束############ 修改完成重启网络服务即可 service network restart ping www.baidu.com 系统环境代理设置编辑文件为/etc/profile，如果只想给自己的账户设置，则编辑~/.bashrc即可 添加三行： \# add proxy for network export http_proxy=&quot;http://child-prc.intel.com:913&quot; export https_proxy=&quot;http://child-prc.intel.com:913&quot; export ftp_proxy=$http_proxy 然后source /etc/profile 或者source ~/.bashrc即可]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>virtualBox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elasticSearch顶尖高手系列-快速入门篇]]></title>
    <url>%2Fpost%2F6a51fa6.html</url>
    <content type="text"><![CDATA[核心概念elasticSearch概念Near Realtime（NRT）近实时，从写入数据到数据可以被搜索到有一个小延迟（大概1秒）；基于es执行搜索和分析可以达到秒级，所以是NRT Cluster集群，包含多个节点，每个节点属于哪个集群是通过一个配置（集群名称，默认是elasticsearch）来决定的，对于中小型应用来说，刚开始一个集群就一个节点很正常 Node节点，集群中的一个节点，节点也有一个名称（默认是随机分配的），节点名称很重要（在执行运维管理操作的时候），默认节点会去加入一个名称为“elasticsearch”的集群，如果直接启动一堆节点，那么它们会自动组成一个elasticsearch集群，当然一个节点也可以组成一个elasticsearch集群 Document&amp;field文档，es中的最小数据单元，一个document可以是一条客户数据，一条商品分类数据，一条订单数据，通常用JSON数据结构表示，每个index下的type中，都可以去存储多个document。一个document里面有多个field，每个field就是一个数据字段。 Index索引，包含一堆有相似结构的文档数据，比如可以有一个客户索引，商品分类索引，订单索引，索引有一个名称。一个index包含很多document，一个index就代表了一类类似的或者相同的document。比如说建立一个product index，商品索引，里面可能就存放了所有的商品数据，所有的商品document。 Type类型，每个索引里都可以有一个或多个type，type是index中的一个逻辑数据分类，一个type下的document，都有相同的field，比如博客系统，有一个索引，可以定义用户数据type，博客数据type，评论数据type。 shard单台机器无法存储大量数据，es可以将一个索引中的数据切分为多个shard，分布在多台服务器上存储。有了shard就可以横向扩展，存储更多数据，让搜索和分析等操作分布到多台服务器上去执行，提升吞吐量和性能。每个shard都是一个lucene index。 replica任何一个服务器随时可能故障或宕机，此时shard可能就会丢失，因此可以为每个shard创建多个replica副本。replica可以在shard故障时提供备用服务，保证数据不丢失，多个replica还可以提升搜索操作的吞吐量和性能。primary shard（建立索引时一次设置，不能修改，默认5个），replica shard（随时修改数量，默认1个），默认每个索引10个shard，5个primary shard，5个replica shard，最小的高可用配置，是2台服务器。 vs数据库核心概念 Elasticsearch 数据库 Document 行 Type 表 Index 库 安装和启动1、安装JDK，至少1.8.0_73以上版本，java -version2、下载和解压缩Elasticsearch安装包，目录结构3、启动Elasticsearch：bin\elasticsearch.bat，es本身特点之一就是开箱即用，如果是中小型应用，数据量少，操作不是很复杂，直接启动就可以用了 问题：max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536] 每个进程最大同时打开文件数太小，可通过下面2个命令查看当前数量 修改/etc/security/limits.conf文件，增加配置，用户退出后重新登录生效 * soft nofile 65536 * hard nofile 65536 问题：max number of threads [3818] for user [es] is too low, increase to at least [4096] 问题同上，最大线程个数太低。修改配置文件/etc/security/limits.conf，增加配置 * soft nproc 4096 * hard nproc 4096 可通过命令查看 ulimit -Hu ulimit -Su 问题：max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144] 修改/etc/sysctl.conf文件，增加配置vm.max_map_count=262144 vi /etc/sysctl.conf sysctl -p 执行命令sysctl -p生效 4、检查ES是否启动成功：http://localhost:9200/?pretty name: node名称cluster_name: 集群名称（默认的集群名称就是elasticsearch）version.number: 5.2.0，es版本号 { &quot;name&quot; : &quot;4onsTYV&quot;,//节点名称 &quot;cluster_name&quot; : &quot;elasticsearch&quot;,//属于集群的名称，在elasticsearch.yml可配置 &quot;cluster_uuid&quot; : &quot;nKZ9VK_vQdSQ1J0Dx9gx1Q&quot;, &quot;version&quot; : {//节点的版本 &quot;number&quot; : &quot;5.2.0&quot;, &quot;build_hash&quot; : &quot;24e05b9&quot;, &quot;build_date&quot; : &quot;2017-01-24T19:52:35.800Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;6.4.0&quot; }, &quot;tagline&quot; : &quot;You Know, for Search&quot; } 5、修改集群名称：elasticsearch.yml6、下载和解压缩Kibana安装包，使用里面的开发界面，去操作elasticsearch，作为我们学习es知识点的一个主要的界面入口7、启动Kibana：bin\kibana.bat8、进入Dev Tools界面9、GET _cluster/health，检查健康状态]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>elasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言基础教程]]></title>
    <url>%2Fpost%2Fa347551a.html</url>
    <content type="text"><![CDATA[go语言快速入门编译和运行编译后的文件会比源文件大很多，因为编译的时候，会把各种依赖库一起编译到可执行文件里。 //默认生成main.exe文件 go build main.go //编译生成其它名字的可执行文件 go build -o newName.exe main.go 把编译的过程放到后台，然后运行。 go run main.go 开发注意事项 源文件必须以go结尾 应用入口是main函数 区分大小写 go语句（所谓语句就是其他语言以分号结尾就是一条语句）后面不需要分号，因为编译会自动加 go编译器是一行行编译的，所以不能再一行里写多条语句 定义的变量和import的包必须使用，否则编译不通]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpSpreadsheet使用]]></title>
    <url>%2Fpost%2F2d7a763a.html</url>
    <content type="text"><![CDATA[样式https://phpspreadsheet.readthedocs.io/en/latest/topics/recipes/#styles getStyle()方法的参数可以是单元格的范围，或者某个单元格；建议一次性设置样式getStyle(‘A1:M500’)，这样速度上会比单独一个个遍历设置速度快的多。 数组的方式当设置多个样式的时候，数组的方式执行速度比较快； $styleArray = [ &#39;font&#39; =&gt; [ &#39;bold&#39; =&gt; true, ], &#39;alignment&#39; =&gt; [ &#39;horizontal&#39; =&gt; \PhpOffice\PhpSpreadsheet\Style\Alignment::HORIZONTAL_RIGHT, ], &#39;borders&#39; =&gt; [ &#39;top&#39; =&gt; [ &#39;borderStyle&#39; =&gt; \PhpOffice\PhpSpreadsheet\Style\Border::BORDER_THIN, ], ], &#39;fill&#39; =&gt; [ &#39;fillType&#39; =&gt; \PhpOffice\PhpSpreadsheet\Style\Fill::FILL_GRADIENT_LINEAR, &#39;rotation&#39; =&gt; 90, &#39;startColor&#39; =&gt; [ &#39;argb&#39; =&gt; &#39;FFA0A0A0&#39;, ], &#39;endColor&#39; =&gt; [ &#39;argb&#39; =&gt; &#39;FFFFFFFF&#39;, ], ], ]; $spreadsheet-&gt;getActiveSheet()-&gt;getStyle(&#39;A3&#39;)-&gt;applyFromArray($styleArray); 字体$spreadsheet-&gt;getActiveSheet() -&gt;getStyle(&#39;B2&#39;) -&gt;getFont() -&gt;getColor() -&gt;setARGB(\PhpOffice\PhpSpreadsheet\Style\Color::COLOR_RED); 设置前景颜色$spreadsheet-&gt;getActiveSheet() -&gt;getStyle(&#39;B3:B7&#39;)-&gt;getFill() -&gt;setFillType(\PhpOffice\PhpSpreadsheet\Style\Fill::FILL_SOLID) -&gt;getStartColor() -&gt;setARGB(&#39;FFFF0000&#39;); 设置对齐//垂直对齐 $spreadsheet-&gt;getActiveSheet() -&gt;getStyle(&#39;B2&#39;) -&gt;getAlignment() -&gt;setHorizontal(\PhpOffice\PhpSpreadsheet\Style\Alignment::HORIZONTAL_RIGHT); 自动换行$spreadsheet-&gt;getActiveSheet()-&gt;getStyle(&#39;A1:D4&#39;) -&gt;getAlignment()-&gt;setWrapText(true); 设置边框//上边框加粗 $spreadsheet-&gt;getActiveSheet() -&gt;getStyle(&#39;B2&#39;) -&gt;getBorders() -&gt;getTop() -&gt;setBorderStyle(\PhpOffice\PhpSpreadsheet\Style\Border::BORDER_THICK); //下边框加粗 $spreadsheet-&gt;getActiveSheet() -&gt;getStyle(&#39;B2&#39;) -&gt;getBorders() -&gt;getBottom() -&gt;setBorderStyle(\PhpOffice\PhpSpreadsheet\Style\Border::BORDER_THICK); //左边框加粗 $spreadsheet-&gt;getActiveSheet() -&gt;getStyle(&#39;B2&#39;) -&gt;getBorders() -&gt;getLeft() -&gt;setBorderStyle(\PhpOffice\PhpSpreadsheet\Style\Border::BORDER_THICK); //右边框加粗 $spreadsheet-&gt;getActiveSheet() -&gt;getStyle(&#39;B2&#39;) -&gt;getBorders() -&gt;getRight() -&gt;setBorderStyle(\PhpOffice\PhpSpreadsheet\Style\Border::BORDER_THICK); //实线填充 $spreadsheet-&gt;getActiveSheet() -&gt;getStyle(&#39;B2&#39;) -&gt;getFill() -&gt;setFillType(\PhpOffice\PhpSpreadsheet\Style\Fill::FILL_SOLID); 设置默认样式//设置字体 $spreadsheet-&gt;getDefaultStyle()-&gt;getFont()-&gt;setName(&#39;Arial&#39;); //设置字体大小 $spreadsheet-&gt;getDefaultStyle()-&gt;getFont()-&gt;setSize(8); 设置列的宽度//固定宽度 $spreadsheet-&gt;getActiveSheet()-&gt;getColumnDimension(&#39;D&#39;)-&gt;setWidth(12); //取最宽的单元格的宽度 $spreadsheet-&gt;getActiveSheet()-&gt;getColumnDimension(&#39;B&#39;)-&gt;setAutoSize(true); 设置行的高度//行10的高度 $spreadsheet-&gt;getActiveSheet()-&gt;getRowDimension(&#39;10&#39;)-&gt;setRowHeight(100); 合并单元格//合并 $spreadsheet-&gt;getActiveSheet()-&gt;mergeCells(&#39;A18:E22&#39;); //移除合并 $spreadsheet-&gt;getActiveSheet()-&gt;unmergeCells(&#39;A18:E22&#39;); 插入行/列//在行7之前插入两个新行 $spreadsheet-&gt;getActiveSheet()-&gt;insertNewRowBefore(7, 2); 数字格式]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php递归树形结构]]></title>
    <url>%2Fpost%2Fbfdcff9a.html</url>
    <content type="text"><![CDATA[php代码&lt;?php header(&quot;Content-type:text/html;Charset=utf8&quot;); /** * 带有html的一维数组，select下拉框使用 * * @param $list * @param int $pid * @param string $itemprefix * @author wqy * @return array * 2019/6/14 014 */ function getTree($list, $pid = 0, $itemprefix = &#39;&#39;) { static $icon = array(&#39;│&#39;, &#39;├&#39;, &#39;└&#39;); static $nbsp = &quot;&amp;nbsp;&quot;; static $arr = array(); $number = 1; foreach ($list as $row) { //第几级 if ($row[&#39;pid&#39;] == $pid) { $brotherCount = 0; //计算当前有多少个兄弟分类 foreach ($list as $r) { if ($row[&#39;pid&#39;] == $r[&#39;pid&#39;]) { $brotherCount++; } } if ($brotherCount &gt; 0) { $j = $k = &#39;&#39;;//$j 修改名称， if ($number == $brotherCount) { //最后一个兄弟 $j .= $icon[2];//&#39;└&#39; $k = $itemprefix ? $nbsp : &#39;&#39;;//$k下一级追加前缀 } else { $j .= $icon[1];//&#39;├&#39; $k = $itemprefix ? $icon[0] : &#39;&#39;;//$k下一级追加前缀 } $spacer = $itemprefix ? $itemprefix . $j : &#39;&#39;;//没有前缀的话不修改名称，用于第一次级 $row[&#39;name&#39;] = $spacer . $row[&#39;name&#39;]; //添加数组 $arr[] = $row; $number++; //不要return返回，可以对变量进行处理而不是嵌套数组 getTree($list, $row[&#39;id&#39;], $itemprefix . $k . $nbsp); } } } return $arr; } /** * 获取孩子数据，用于条件判断，是否是某个分类的孩子 * * @param $list * @param int $pid * @author wqy * @return array * 2019/6/14 014 */ function getTreeChildren($list, $pid = 0) { static $arr = []; foreach ($list as $row) { if ($row[&#39;pid&#39;] == $pid) { array_push($arr, $row); getTreeChildren($list, $row[&#39;id&#39;]); } } return $arr; } /** * 获取孩子数据,嵌套，用于菜单 * * @param $list * @param $pid * @author wqy * @return mixed * 2019/6/14 014 */ function getTreeChildrenNest($list, $pid) { $arr = []; foreach ($list as $row) { if ($row[&#39;pid&#39;] == $pid) { $row[&#39;child&#39;] = getTreeChildrenNest($list, $row[&#39;id&#39;]);//先序递归 array_push($arr, $row); } } return $arr; } //$list 模拟数据库查询出来的数据 $list = [ [&#39;id&#39; =&gt; 1, &#39;pid&#39; =&gt; 0, &#39;name&#39; =&gt; &#39;总经理&#39;], [&#39;id&#39; =&gt; 2, &#39;pid&#39; =&gt; 1, &#39;name&#39; =&gt; &#39;人事部经理&#39;], [&#39;id&#39; =&gt; 3, &#39;pid&#39; =&gt; 2, &#39;name&#39; =&gt; &#39;人事一组长&#39;], [&#39;id&#39; =&gt; 4, &#39;pid&#39; =&gt; 3, &#39;name&#39; =&gt; &#39;人事一组职员1&#39;], [&#39;id&#39; =&gt; 5, &#39;pid&#39; =&gt; 3, &#39;name&#39; =&gt; &#39;人事一组职员2&#39;], [&#39;id&#39; =&gt; 6, &#39;pid&#39; =&gt; 3, &#39;name&#39; =&gt; &#39;人事一组职员3&#39;], [&#39;id&#39; =&gt; 7, &#39;pid&#39; =&gt; 2, &#39;name&#39; =&gt; &#39;人事二组长&#39;], [&#39;id&#39; =&gt; 8, &#39;pid&#39; =&gt; 7, &#39;name&#39; =&gt; &#39;人事二组职员1&#39;], [&#39;id&#39; =&gt; 9, &#39;pid&#39; =&gt; 7, &#39;name&#39; =&gt; &#39;人事二组职员2&#39;], [&#39;id&#39; =&gt; 10, &#39;pid&#39; =&gt; 7, &#39;name&#39; =&gt; &#39;人事二组职员3&#39;], [&#39;id&#39; =&gt; 11, &#39;pid&#39; =&gt; 1, &#39;name&#39; =&gt; &#39;技术部经理&#39;], [&#39;id&#39; =&gt; 12, &#39;pid&#39; =&gt; 11, &#39;name&#39; =&gt; &#39;技术一组长&#39;], [&#39;id&#39; =&gt; 13, &#39;pid&#39; =&gt; 12, &#39;name&#39; =&gt; &#39;技术一组职员1&#39;], [&#39;id&#39; =&gt; 14, &#39;pid&#39; =&gt; 12, &#39;name&#39; =&gt; &#39;技术一组职员2&#39;], [&#39;id&#39; =&gt; 15, &#39;pid&#39; =&gt; 12, &#39;name&#39; =&gt; &#39;技术一组职员3&#39;], ]; print_r(getTreeChildrenNest($list,0));]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php数组-实例.md]]></title>
    <url>%2Fpost%2F7abb40af.html</url>
    <content type="text"><![CDATA[增删改查增数组后面追加元素 array_push($arr,&#39;element&#39;); $arr[] = &#39;element&#39;; 数组$index位置更新或者添加元素，注意：如果$index是字符串，也会在指定的位置（字符升序）添加元素，如果不存在则是新增，否则为更新。不建议通过这种方式添加，出现问题的概率会比较大，因为有时候并不是新增，如果是字符串索引，顺序还不好确定，除非在添加数组元素的时候要对键值进行升序排序的情况下才比较时候，否则这种方式基本上是用于更新数组值的场景 $arr[$index] = &#39;element&#39;;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[listary使用]]></title>
    <url>%2Fpost%2F2b279d40.html</url>
    <content type="text"><![CDATA[安装破解下载百度网盘里的即可 设置关键字 操作 说明 gg 打开浏览器并且打开google bd 打开浏览器并且打开baidu .. 返回上一级文件夹 文件夹名称 进入该文件夹 hosts 编辑hosts文件 mkdir folder-name 创建文件夹，并且进入该文件夹 new test.txt 创建文件 自定义关键字，不想显示 cmd 窗口可以勾选「静默执行」 关键字： new显示名称： 创建文件 “{query}”路径： %ComSpec%参数： /c type nul &gt;&gt; “{query}” 动作 操作 说明 Ctrl + C 复制 Ctrl + X 剪切 Ctrl + Shift + C 复制文件的路径 Ctrl + Enter 打开文件所在的文件夹 Alt + N notePad++打开]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>listary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ditto使用]]></title>
    <url>%2Fpost%2F1fcd234f.html</url>
    <content type="text"><![CDATA[设置常规设置 最大数目设置为50 过期日期为1天 键盘快捷键设置 分组设置 修改标题 禁止自动删除因为软件设置一天之后或者大于设置的条数之后会自动删除，左边有个五角星星 快捷键 按钮 说明 Win + V 弹出面板 Shift + Enter 纯文本粘贴 Ctrl + N 新建 Ctrl + E 编辑 Ctrl + G 查看组 Alt + Enter 修改标题和分组]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ditto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime]]></title>
    <url>%2Fpost%2F238c95be.html</url>
    <content type="text"><![CDATA[快捷键 1、ctrl+L是选择一行；2、ctrl+shift+d复制一行到下一行；3、ctrl+]右缩进4、ctlr+[左缩进5、ctrl+shift+up/down上下行交换6、ctrl+j与上一行合并；7、ctrl+enter在行后增加一行；8、ctrl+shift+enter在行前增加一行；9、ctrl+shift+k删除一行10、ctr+G跳到指定行11、ctr+F查找12、ctrl+F3快速查找13、F3查找下一个14、shift+F3查找上一个15、ctrl+shift+F查找文件里的内容16、ctrl+H查找替换17、ctrl+P查找文件18、ctrl+~调出命令控制器19、ctrl+shift+P调出安装界面 插件 1、DocBlockr插件注释；2、BracketHighlighter，用于匹配括号，引号和html标签。3、Emmet(Zen Coding)，快速生成HTML代码段的插件4、SideBarEnhancements，侧边栏显示打开的文件，右键点击文件多了许多功能5、Phpcs，php代码提示，报错提示等6、jsFormat，将压缩的js展现7、Alignment，等号对其，快捷要重新设置，与qq截屏冲突8、Jquery，jquery提示9、TrailingSpaces，多余空格提示，一键删除的话，需要配置快捷键盘]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[composer]]></title>
    <url>%2Fpost%2F987306d8.html</url>
    <content type="text"><![CDATA[composer作用就像一个php的应用商店，从应用商店上下载软件到php项目； 工作过程通过pakagist.org网站，去版本库（GitHub等）上下载软件； 安装软件 全局安装 mv composer.phar /usr/local/bin/composer 局部安装 下载归档文件（composer.phar），放到项目目录中执行 php -r &quot;readfile(&#39;https://getcomposer.org/installer&#39;);&quot; | php curl -sS https://getcomposer.org/installer | php 发布到pakagist.org 创建composer.json文件 传到github仓库，设置钩子有更新自动同步到pakagist.org 在pakagist.org上设置项目地址 自动加载 直接引入vendor里的autoload.php require &#39;vendor/autoload.php&#39;; 配置composer.json里的autoload选项，增加自己的 autoloader { &quot;autoload&quot;: { &quot;psr-4&quot;: {&quot;Acme\\&quot;: &quot;src/&quot;}//src目录和vendor同级 } } classmap支持 不使用autoloader，可以仅仅引入vendor/composer/autoload_*.php文件，它返回一个关联数组 composer.json文件链接网址：https://docs.phpcomposer.com/04-schema.html { &quot;name&quot;: &quot;yiisoft/yii2-app-advanced&quot;,//包名,它包括供应商名称和项目名称，使用 / 分隔,对于需要发布的包（库），这是必须填写的 &quot;description&quot;: &quot;Yii 2 Advanced Project Template&quot;,//一个包的简短描述。通常这个最长只有一行,对于需要发布的包（库），这是必须填写的。 &quot;keywords&quot;: [&quot;yii2&quot;, &quot;framework&quot;, &quot;advanced&quot;, &quot;project template&quot;],//关键字，该包相关的关键词的数组。这些可用于搜索和过滤。 &quot;version&quot;: &quot;1.0.0&quot;,//不是必须的，并且建议忽略,应该符合 X.Y.Z 或者 vX.Y.Z 的形式， -dev、-patch、-alpha、-beta 或 -RC 这些后缀是可选的 /** * 1、library:这是默认类型，它会简单的将文件复制到 vendor 目录 * 2、project:这表示当前包是一个项目，而不是一个库 * 3、metapackage:当一个空的包，包含依赖并且需要触发依赖的安装，这将不会对系统写入额外的文件，因此这种安装类型并不需要一个 dist 或source * 4、composer-plugin：它有一个自定义安装类型，可以为其它包提供一个 installler */ &quot;type&quot;: &quot;project&quot;,//包的安装类型，默认为 library &quot;homepage&quot;: &quot;http://www.yiiframework.com/&quot;,//该项目网站的 URL 地址，可选 &quot;time&quot;: &quot;2018-08-05&quot;,//版本发布时间,必须符合 YYYY-MM-DD 或 YYYY-MM-DD HH:MM:SS 格式,可选 /** * 包的许可协议，它可以是一个字符串或者字符串数组或可以由 o r 或an d 分隔，并写在括号中,可选，但强烈建议提供此内容，对于闭源软件，你必须使用 &quot;proprietary&quot; 协议标识符 * * Apache-2.0 * BSD-2-Clause * BSD-3-Clause * BSD-4-Clause * GPL-2.0...... */ &quot;license&quot;: &quot;BSD-3-Clause&quot;,// &quot;authors&quot;: { &quot;name&quot;: &quot;wqy&quot;,//作者的姓名，通常使用真名 &quot;email&quot;: &quot;tinyearthworm@gmail.com&quot;,//作者的 email 地址 &quot;homepage&quot;: &quot;http://&quot;,//作者主页的 URL 地址 &quot;role&quot;: &quot;Developer&quot;,//该作者在此项目中担任的角色（例：开发人员 或 翻译） },//可选，但是强烈建议，如果有的话，必须包含上面4项 &quot;support&quot;: { &quot;email&quot;: &quot;support@example.org&quot;,//项目支持 email 地址 &quot;irc&quot;: &quot;irc://irc.freenode.org/composer&quot;,//IRC 聊天频道地址 &quot;issues&quot;: &quot;&quot;,//跟踪问题的 URL 地址 &quot;forum&quot;: &quot;&quot;,//论坛地址 &quot;wiki&quot;: &quot;&quot;,// Wiki 地址 &quot;source&quot;: &quot;&quot;,//网址浏览或下载源 },//获取项目支持的向相关信息对象,可选，必须包含以上 /****下面提到的所有对象，都应该是包名到 版本的映射对象，都是可选的*****/ &quot;require&quot;: { &quot;monolog/monolog&quot;: &quot;1.0.*@beta&quot;, &quot;acme/foo&quot;: &quot;@dev&quot;//稳定性标签@，仅针对root包 }, /** * 1、这个列表是为开发或测试等目的，额外列出的依赖 * 2、“root 包”的 require-dev 默认是会被安装的 * 3、 install 或 update 支持使用 --no-dev 参数来跳过 require-dev 字段中列出的包 * * 包的版本号： * 确切的版本号，如：1.0.2 * 范围，如&gt;=1.0 * 通配符，如1.0*，等效&gt;=1.0,&lt;1.1 * 赋值运算符，如~1.2，相当于&gt;=1.2,&lt;2.0 */ &quot;require-dev&quot;:{ },//root-only, /** * 1、此列表中的包与当前包的这个版本冲突时候，它们将不允许同时被安装 */ &quot;conflict&quot;: { } /** * 1、这个列表中的包将被当前包取代 */ &quot;replace&quot;: { } /** * 1、这个包提供的其他软件包的列表。 */ &quot;provide&quot;: { } /** * 1、建议安装的包，它们增强或能够与当前包良好的工作 * 2、这些只是信息，并显示在依赖包安装完成之后，给你的用户一个建议，他们可以添加更多的包 */ &quot;suggest&quot;: { &quot;monolog/monolog&quot;: &quot;Allows more advanced logging of the application flow&quot; } /** * 1、PHP autoloader 的自动加载映射 * 2、命名空间要以\结尾，不然Foo\\ and FooBar\\ 就不好区别 * */ &quot;autoload&quot;: { /** * 1、PSR-4被推荐，如：自动加载类Foo\\Bar\\Baz，命名空间Foo\\=&gt;src/，等效自动加载src/bar/baz.php * 2、在install/update过程中，PSR-4引用都将被结合为一个单一的键值对数组，存储至 vendor/composer/autoload_psr4.php 文件中 */ &quot;psr-4&quot;: { &quot;Monolog\\&quot;: &quot;src/&quot;,// &quot;Vendor\\Namespace\\&quot;: &quot;&quot;, &quot;Monolog\\&quot;: [&quot;src/&quot;, &quot;lib/&quot;],//多个目录中搜索同样的前缀 &quot;&quot;: &quot;src/&quot;,//多个命名空间，回调目录，没找到最后都往这找 }, /** * 1、定义了一个命名空间到实际路径的映射（相对于包的根目录） * 2、支持PEAR-style方式的约定（与命名空间不同，PEAR 类库在类名上采用了下划线分隔） * 3、在 install/update 过程中，PSR-0 引用都将被结合为一个单一的键值对数组，存储至 vendor/composer/autoload_namespaces.php 文件中 */ &quot;psr-0&quot;: { &quot;Monolog\\&quot;: &quot;src/&quot;,//命名空间类型 &quot;Vendor\\Namespace\\&quot;: &quot;src/&quot;, &quot;Vendor_Namespace_&quot;: &quot;src/&quot;,//pear-style类型 &quot;Monolog\\&quot;: [&quot;src/&quot;, &quot;lib/&quot;],//搜索多个目录中一个相同的前缀，你可以将它们指定为一个数组 &quot;UniqueGlobalClass&quot;: &quot;&quot;,//可以是精确到类级别的指定,唯一的类名称 &quot;&quot;: &quot;src/&quot;,//设置一个目录作为任何命名空间的备用目录 }, /** * 1、classmap 引用的所有组合，都会在 install/update 过程中生成，并存储到 vendor/composer/autoload_classmap.php 文件中 * 2、对于不遵循 PSR-0/4 规范的类库 */ &quot;classmap&quot;: [ &quot;src/&quot;, &quot;lib/&quot;, &quot;Something.php&quot;//支持直接精确到文件 ], /** * 1、每次请求时都要载入某些文件 */ &quot;files&quot;: [ &quot;src/MyLibrary/functions.php&quot; ] } /** * 开发环境下的自动加载(root-only) */ &quot;autoload-dev&quot;: { &quot;psr-4&quot;: { &quot;MyLibrary\\Tests\\&quot;: &quot;tests/&quot; } }, //这是目前唯一支持传统项目的做法，所有新的代码都建议使用自动加载 &quot;include-path&quot;: [&quot;lib/&quot;], /** * 定义当前包安装的目标文件夹 * 若某个包的根目录，在它申明的命名空间之下，将不能正确的使用自动加载 */ &quot;target-dir&quot;: &quot;Symfony/Component/Yaml&quot;, /** * 定义了通过稳定性过滤包的默认行为 * 默认是stable * dev（开发包） */ &quot;minimum-stability&quot;:&quot;stable&quot;,//默认的 //Composer 将优先使用更稳定的包版本 &quot;prefer-stable&quot;: true, /** * 使用自定义的包资源库(root-only) * 默认情况下 composer 只使用 packagist 作为包的资源库 * 顺序是非常重要的，当 Composer 查找资源包时，它会按照顺序进行 * 默认情况下 Packagist 是最后加入的，因此自定义设置将可以覆盖 Packagist 上的包 */ &quot;repositories&quot;: { &quot;packagist&quot;: { &quot;type&quot;: &quot;composer&quot;,//composer,vcs,pear,package &quot;url&quot;: &quot;https://packagist.phpcomposer.com&quot; } }, /** * root-only,仅用于项目，root包 * * */ &quot;config&quot;: { &quot;bin-dir&quot;: &quot;bin&quot; } } 命令网址：https://docs.phpcomposer.com/03-cli.html#Global-Options /** * 创建composer.json文件 * 填写指定的参数 */ composesr init /** * 1、从当前目录读取 composer.json 文件，处理了依赖关系，并把其安装到 vendor 目录下 * 2、会自动创建一个composer.lock * 3、之后该命令检查composer.lock是否存在，存在则从该文件下载指定的版本，忽略composer.json文件 * 该命令是会将依赖下载到vendor目录 */ composer install composer install --dev //安装 require-dev 字段中列出的包（这是一个默认值） composer install --no-dev//跳过 require-dev 字段中列出的包 /** * 问题：在install时候遇到需要githhub oauth token 不能fetch * 答：去GitHub创建 new token，然后输入即可 */ /** * 1、为了获取依赖的最新版本，并且升级 composer.lock 文件 * 2、update命令会根据composer.json文件获取最新的依赖，并且更新composer.lock文件 */ composer update //更新所有的依赖 composer update monolog/monolog vendor/package2//白名单依赖，更新一个依赖 composer update vendor/* //使用通配符进行批量更新 {1} /** * 增加新的依赖包到当前目录的 composer.json 文件中 * –prefer-dist:对于稳定的包来说,一般Composer安装默认使用该参数,这也能加快安装,比如有可能直接从packagist安装了相应的包,而不用实际去Github上下载包. * –prefer-source:假如使用该参数,则会直接从Github上安装,安装包后vendor目录下还含有.git信息 */ composer require //通过交互来指定依赖包 composer require vendor/package:2.* vendor/package2:dev-master//直接指明依赖包 /** * 全局执行 global ??? * global 命令允许你在 COMPOSER_HOME 目录下执行其它命令，像 install、require 或 update */ php composer.phar global require fabpot/php-cs-fixer:dev-master /** * 当前项目搜索依赖包 * */ composer search monolog /** * 列出所有可用的软件包 * */ composer show //显示所有 composer show --installed//显示已经安装的 composer show show monolog/monolog//显示一个包信息 composer show show monolog/monolog 1.0.2//显示某个版本的包信息 /** * 在提交 composer.json 文件，和创建 tag 前，你应该始终运行 validate 命令 * 它将检测你的 composer.json 文件是否是有效的 */ composer validate /** * 允许你进行检查，如果你有任何本地的更改它将会给予提示 * 依赖被修改了 */ php composer.phar status -v /** * 将 Composer 自身升级到最新版本，只需要运行 self-update 命令 * */ php composer.phar self-update /** * 编辑 Composer 本地的 的omposer.json * 编辑 Composer 全局的 config.json */ php composer.phar config --list php composer.phar config repositories.foo vcs http://github.com/foo/bar //修改包来源 composer config repo.packagist composer https://packagist.phpcomposer.com//单个项目的中国镜像配置，composer.json composer config -g repo.packagist composer https://packagist.phpcomposer.com//全局的中国镜像配置，config.json /** * 创建项目 * 相当于执行了一个 git clone后将这个包的依赖安装到它自己的 vendor 目录 * 传递一个包名，它会为你创建项目的目录; * 可以在第三个参数中指定版本号，否则将获取最新的版本; * 代码和依赖在同一个目录，相当于执行了一个git clone命令,一般是包的开发者可能为了修复bug会使用该命令. */ php composer.phar create-project doctrine/orm path 2.2.* /** * 优化下自动加载 * */ composer dump-autoload --optimize //优化一下自动加载 注意请求github有时候需要token，去注册一个token纯起来就可以了]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php7.2.3编译安装]]></title>
    <url>%2Fpost%2F25312b9b.html</url>
    <content type="text"><![CDATA[官网下载解压configure# ----------------------------------------------------------------- # -----------配置说明，使用的时候要去出注释----------------------------- # ------------------------------------------------------------------ ./configure \ --prefix=/usr/local/lnmp/php7.2 \ --exec-prefix=/usr/local/lnmp/php7.2 \ #bin,sbin,libdir,include,share默认都在这目录下 --with-config-file-path=/usr/local/lnmp/php7.2/etc \ #设置配置文件的路径 --with-libdir=lib64 \ #64位默认的库文件在/usr/lib64下，[EPREFIX/lib] --with-apxs2=/usr/local/apache/bin/apxs \ #apache(sapi)安装才需要这个选项 --enable-fpm \ #fcgi下的sapi --with-fpm-user=php-fpm\ --with-fpm-group=php-fpm\ --with-fpm-systemd\ #支持systemd来管理php-fpm --with-pcre-regex \ #正则表达式支持 --enable-mbregex \ --enable-sockets \ # 打开 sockets 支持 --with-curl \ #curl支持 --with-kerberos \ #支持DES加密算法 --with-mhash \ #mhash算法的扩展 --with-mcrypt \ #mcrypt算法的扩展 --with-mysqli \ #支持mysqlnd自然驱动 --with-pdo-mysql \ #mysql pdo连接支持 --with-pdo-sqlite \ #pdo的sqlite支持 --with-gettext \ #打开gnu 的gettext 支持，编码库用到 --with-iconv-dir \ #支持iconv函数，字符编码强制转换 --enable-mbstring \ #多字节，字符串的支持，解决其他语言编码不能正确显示的问题 --with-freetype-dir \ #打开对freetype字体库的支持 --enable-gd-native-ttf \ #支持TrueType字符串函数库 --with-png-dir \ #打开对png格式的支持 --with-jpeg-dir \ #打开对jpeg图片的支持 --enable-bcmath \ #打开图片大小调整,用到zabbix监控的时候用到了这个模块 --with-gd \ #打开gd库的支持，二维码生成 --with-libxml-dir \ #打开libxml2库的支持，dom对象xml解析 --with-openssl \ #openssl的支持，加密传输时用到的，url流https://，ftps:// --with-pear \ #php的扩展应用仓库 --with-xmlrpc \ # 打开xml-rpc的c语言 --with-xsl \ #打开XSLT 文件支持，扩展了libXML2库 ，需要libxslt软件 --with-zlib \ #流compress.zlib://来访问gizp文件 --with-zlib-dir \ #打开zlib库的支持 --with-bz2\ #提供compress.bzip2://处理层，bz2文件支持 --with-openssl-dir \ --enable-gd-jis-conv \ --enable-libxml \ --enable-inline-optimization \ --enable-opcache \ --enable-pcntl \ #freeTDS需要用到的，可能是链接mssql 才用到 --enable-shmop \ --enable-soap \ --enable-sysvsem \ --enable-xml \ --enable-zip #打开对zip的支持 # ----------------------------------------------------------------- # ----------配合nginx可以直接复制以下配置---------------------------- # ------------------------------------------------------------------ ./configure \ --prefix=/usr/local/lnmp/php7.2 \ --exec-prefix=/usr/local/lnmp/php7.2 \ --with-config-file-path=/usr/local/lnmp/php7.2/etc \ --with-libdir=/usr/lib \ --enable-fpm \ --with-fpm-user=php-fpm\ --with-fpm-group=php-fpm\ --with-pcre-regex \ --enable-mbregex \ --enable-sockets \ --with-curl \ --with-kerberos \ --with-mhash \ --with-mcrypt \ --with-mysqli \ --with-pdo-mysql \ --with-pdo-sqlite \ --with-gettext \ --with-iconv-dir \ --enable-mbstring \ --with-freetype-dir \ --enable-gd-native-ttf \ --with-png-dir \ --with-jpeg-dir \ --enable-bcmath \ --with-gd \ --with-libxml-dir \ --with-openssl \ --with-pear \ --with-xmlrpc \ --with-xsl \ --with-zlib \ --with-zlib-dir \ --with-bz2\ --with-openssl-dir \ --enable-gd-jis-conv \ --enable-libxml \ --enable-inline-optimization \ --enable-opcache \ --enable-pcntl \ --enable-shmop \ --enable-soap \ --enable-sysvsem \ --enable-xml \ --enable-zip 依赖configure: error: libxml2 not found. Please check your libxml2 installation #libxml2库,解析xml文档用的 yum -y install libxml2 libxml2-devel configure: error: Cannot find OpenSSL&#39;s &lt;evp.h&gt; #opensll库 yum install openssl openssl-devel configure: error: Please reinstall the BZip2 distribution yum install bzip2 bzip2-devel configure: error: cURL version 7.10.5 or later is required to compile php with cURL suppor #curl库 yum -y install curl curl-devel configure: error: jpeglib.h not found #libjpeg库 yum -y install libjpeg libjpeg-devel configure: error: png.h not found #libjpeg库 yum -y install libpng libpng-devel configure: error: freetype-config not found #freetype字体库 yum -y install freetype freetype-devel configure: error: xslt-config not found. Please reinstall the libxslt &gt;= 1.1.0 distribution yum -y install libxslt libxslt-devel 其它可能需要的扩展 #mysql库 yum -y install mysql mysql-devel #正则 yum -y install pcre pcre-devel #libxslt 库 yum -y install libxslt libxslt-devel #mcrypt库，yum上面没有 yum localinstall libmcrypt libmcrypt-devel wget http://mirrors.hust.edu.cn/epel/6/x86_64/libmcrypt-2.5.8-9.el6.x86_64.rpm wget http://mirrors.hust.edu.cn/epel/6/x86_64/libmcrypt-devel-2.5.8-9.el6.x86_64.rpm makemake install配置#configure目录下找到文件复制 cp php.ini-production /usr/local/lnmp/php7.2/etc/php.ini #在安装目录下找到复制文件 cp /usr/local/php7/etc/php-fpm.conf.default /usr/local/lnmp/php7.2/etc/php-fpm.conf #在安装目录下找到复制文件 cp /usr/local/php7.2/etc/php-fpm.d/www.conf.default /usr/local/lnmp/php7.2/etc/php-fpm.d/www.conf 添加服务#在configure的目录下 cp ./sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm chmod +x /etc/init.d/php-fpm #添加www用户 useradd www #配置/usr/local/lnmp/php7.2/etc/php-fpm.d/www.conf文件里的用户组和用户为www user = www group = www #添加服务chkconfig --list chkconfig --add php-fpm]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yii-模型]]></title>
    <url>%2Fpost%2F37c4afc8.html</url>
    <content type="text"><![CDATA[rules规则 /** * 规则 */ public function rules() { return [ //when条件比较 [&#39;wait_amount&#39;, &#39;required&#39;, &#39;when&#39; =&gt; function ($model) { return $model-&gt;purchase_product_id != &#39;&#39;; }], //与属性值比较 [&#39;amount&#39;, &#39;compare&#39;, &#39;compareAttribute&#39; =&gt; &#39;wait_amount&#39;, &#39;operator&#39; =&gt; &#39;&lt;=&#39;], //默认值 [[&#39;purchase_product_id&#39;, &#39;wait_amount&#39;], &#39;default&#39;, &#39;value&#39; =&gt; 0,], //trim [[&#39;amount&#39;, &#39;weight&#39;], &#39;trim&#39;,], //与某个值比较 [[&#39;amount&#39;, &#39;weight&#39;], &#39;compare&#39;, &#39;compareValue&#39; =&gt; 0, &#39;operator&#39; =&gt; &#39;&gt;&#39;,], //不能为空 [[&#39;entity_id&#39;, &#39;inbound_id&#39;,], &#39;required&#39;], //必须是整数 [[&#39;entity_id&#39;, &#39;inbound_id&#39;, &#39;product_id&#39;,], &#39;integer&#39;], //必须是数字 [[&#39;weight&#39;, &#39;total_weight&#39;], &#39;number&#39;], //必须是字符串 [[&#39;remark&#39;], &#39;string&#39;, &#39;max&#39; =&gt; 255], //验证并且转换为时间搓格式 [[&#39;orderTimeEnd&#39;], &#39;date&#39;, &#39;format&#39; =&gt; &#39;php:Y-m-d&#39;, &#39;timestampAttribute&#39; =&gt; &#39;orderTimeEndTimestamp&#39;,], [&#39;contact_tel&#39;, &#39;match&#39;, &#39;pattern&#39; =&gt; &#39;/^1[34578]{1}\d{9}$/&#39;, &#39;message&#39; =&gt; &#39;联系电话格式错误.&#39;], ]; }]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>yii</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解sql子句]]></title>
    <url>%2Fpost%2Fb98e5f11.html</url>
    <content type="text"><![CDATA[order by基本规则 优先级：就近原则顺序：字段1相同才排序才用到字段2排序，字段2相同才用到字段3排序规则 使用场景一个字段排序order by 字段1 DESC; 这种没什么好说的，就按该字段的大小排序就好了； 两个字段以及以上排序order by 字段1 DESC,字段2 DESC; 必将涉及到组的概念，可以将最后一个字段以外的字段理解成一组，后一个字段将在前一个字段组内进行排序； 例如：可以把字段1理解被按大小排序好的组，字段2是在字段1组内进行排序；如果字段1的组就一条记录，那么字段2的组内排序相当于被忽略；]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpstorm插件]]></title>
    <url>%2Fpost%2F3bf849ad.html</url>
    <content type="text"><![CDATA[.ignore 编辑git的ignore文件的插件 editorconfig 回车换行等标准，需要建立一个.editorconfig文件 composerjson support 安装之后composerjson文件能自动提示，检查语法错误 Laravel Plugin LV框架自动跳转的插件 .env files support 环境文件支持 yii2support yii2框架支持控制器自动跳转到模板等功能 CamelCase 驼峰命名和下滑线命名快速转化，快捷键是shift+alt+u Chinese PHP Document 中文文档，快捷键ctrl+q]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>phpStorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpStorm常用设置]]></title>
    <url>%2Fpost%2F63323c.html</url>
    <content type="text"><![CDATA[注释靠近代码 setting设置搜索：comment code 数组键值对齐 setting设置搜索：array declaration style Tab标签的个数限制 setting设置搜索：tab limit 引号自动包裹选择的字符串 setting设置搜索：surround selection on typing quote or brace]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>phpStorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[navicat]]></title>
    <url>%2Fpost%2Fd4ee0365.html</url>
    <content type="text"><![CDATA[快捷键命令窗口F6 历史记录CTRL+H 新建查询ctrl+q 修改表ctrl+d]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>navicat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pecl]]></title>
    <url>%2Fpost%2Feb3635c.html</url>
    <content type="text"><![CDATA[什么是pecl PHP extension community library，是一个社区库； 用于安装php的扩展 安装 安装php的时候已经默认安装了 使用查看帮助pecl -h 安装pecl install packageName #可以安装已经下载好的安装包 pecl install /vagrant/xdebug-2.6.1.tgz]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php-fpm管理php进程]]></title>
    <url>%2Fpost%2F191b2c68.html</url>
    <content type="text"><![CDATA[基本命令帮助php-fpm -h 测试php-fpm配置文件php-fpm -t 服务 服务方式管理，必须先加入服务 service php-fpm {start|stop|force-quit|restart|reload|status|configtest}]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php安装扩展]]></title>
    <url>%2Fpost%2Ff3e09151.html</url>
    <content type="text"><![CDATA[yum安装扩展#查看5.5版本的扩展有哪些 yum list | grep php55w* #找到扩展名称安装 yum -y install php55w-pecl-redis.x86_64 注意： 注意版本 安装之后要重启 要安装php-devel：yum install php-devel phpize安装扩展pecl网站上，下载对应的版本执行phpize 命令bin/phpize --with-php-config=bin/php-config 编译安装./configure --with-php-config=bin/php-config make make install 注意：编译会依赖：m4、autoconf yum install m4 yum install autoconf pecl安装#查看可用的包，找到要安装的包 pecl serch mongodb #安装 pear install mongodb]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window10常用快捷键]]></title>
    <url>%2Fpost%2Ff713c4e6.html</url>
    <content type="text"><![CDATA[查看历史剪切板win+v 浏览器书签切换TAB+CTRL 翻译ctrl+alt+d 虚拟桌面#创建 Win + Ctrl + D #关闭 Win + Ctrl + F4 #切换 Win + Ctrl +←/→ 调出虚拟桌面Win+Tab 设置win+i 锁屏win+L 暂时回到桌面win+, 打开工作区#草稿等 win+w 打开蓝牙设备win+k 打开我的电脑win+e 锁屏win+l 新建文件夹ctrl+shift+n 关闭窗口alt+f4]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows7旗舰版系统重装]]></title>
    <url>%2Fpost%2Ff118c972.html</url>
    <content type="text"><![CDATA[下载镜像32位下载-cn_windows_7_ultimate_x86_dvd_x15-65907.iso64位下载-cn_windows_7_ultimate_x64_dvd_x15-66043.iso u盘启动工具制作 下载软碟通（软碟通下载地址），安装完成，将下载的系统打开，准备一个U盘 安装这样系统就在U盘里了，下一步安装系统，将刚写入系统的U盘插在电脑，开机将BIOS（一般按F12进入） 第一启动改为U盘，不清楚可以留言或者直接百度很简单的。然后电脑开机就会进入如下界面 选择我接受许可条款 选择自定义 破解下载-Windows Loader.zip安装 删除c盘下的旧的系统文件 右键点击c盘-&gt;选择属性 选择常规-&gt;磁盘清理 选择清理系统文件-&gt;选择旧的window系统]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[crontab使用]]></title>
    <url>%2Fpost%2F9407bf68.html</url>
    <content type="text"><![CDATA[格式crontab [-u user] {-l | -r | -e} -u：设定某个用户的cron服务 -e：执行文字编辑器来设定时程表，可添加删除 -r：删除目前的时程表 -l：列出目前的时程表 帮助crontab --help 日志查看tail -f /var/log/cron Crontab文件的格式为 ”M H D m d cmd” M代表分钟（0~59）, H代表小时(0~23), D代表天(1~31), m代表月(1~12)， d代表一星期内的天(0~6,0为星期天) cmd代表执行命令 例子 每天早上6点10分：10 6 * * * 每两个小时：0 */2 * * * 每个月的4号和每个礼拜一到礼拜三的早上11点：0 11 4 * 1-3 1月1日早上4点：0 4 1 1 *]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[memcached安装]]></title>
    <url>%2Fpost%2F7a8b8960.html</url>
    <content type="text"><![CDATA[下载wget http://memcached.googlecode.com/files/memcached-1.2.8.tar.gz 编译编译 configure ./configure --prefix=/usr/local/lnmp/memcached1.2.5/ --with-libevent=/usr/local/libevent/ make make install 可能的依赖 configure: error: libevent is required yum -y install libevent ibevent-devel 可能的问题memcached.c:657: error: &#39;IOV_MAX&#39; undeclared (first use in this function) 问题定位： 查看memcached.c，搜索IOV_MAX，可以看到它是这样使用的： /* FreeBSD 4.x doesn&#39;t have IOV_MAX exposed. */ #ifndef IOV_MAX #if defined(__FreeBSD__) || defined(__APPLE__) # define IOV_MAX 1024 #endif #endif 是系统环境问题。 解决方式： 修改为： /* FreeBSD 4.x doesn&#39;t have IOV_MAX exposed. */ #ifndef IOV_MAX //#if defined(__FreeBSD__) || defined(__APPLE__) # define IOV_MAX 1024 //#endif #endif]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>memcached</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx常见问题]]></title>
    <url>%2Fpost%2F303cf186.html</url>
    <content type="text"><![CDATA[msys2编译安装Nginx，提示nginx: [emerg] the maximum number of files supported by select() is 64 表示FD_SETSIZE的值比nginx配置文件中worker_connections指令所指定的值小，你可以把 nginx.conf 里的 worker_connections 选项改小一些，比如改为30就好了]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vagrant管理]]></title>
    <url>%2Fpost%2F5329de73.html</url>
    <content type="text"><![CDATA[常用vagrant命令#显示版本 vagrant --version # 初始化 vagrant init # 启动虚拟机 vagrant up # 关闭虚拟机 vagrant halt # 重启虚拟机 vagrant reload # SSH 至虚拟机 vagrant ssh # 挂起虚拟机 vagrant suspend # 唤醒虚拟机 vagrant resume # 查看虚拟机运行状态 vagrant status # 销毁当前虚拟机 vagrant destroy 打包#进入virtualbox目录 vboxmanage list vms #进入vagrant的工作目录 vagrantworkdircentos7.2&gt;vagrant package --base vagrant package --base vagrantworkdircentos72_default_1551522790380_35654 --output D:/centos72_wqy.box ssh管理命令#查看ssh配置 vagrant ssh-config box管理命令# 查看本地box列表ba vagrant box list # 添加box到列表 vagrant box add # 从box列表移除 vagrant box remove]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vagrant</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx安装]]></title>
    <url>%2Fpost%2F16fe430b.html</url>
    <content type="text"><![CDATA[安装./configure --prefix=/usr/local/lnmp/nginx，比较简单 make make install 依赖rewrite模块需要用到正则表达式（pcre），可以选择禁用不安装 yum install pcre yum install pcre-devel #头文件，二次开发时候需要用到的库 gzip模块需要用到zlib库，可以选择禁用不安装，某些content-type响应时候可以进行压缩,gzip on yum install -y zlib yum install -y zlib-devel 编译c语言程序需要 yum install gcc yum install gcc-c++ MD5，SHA1的散列函数，https的SSL协议传输http需要用到OpenSLL yum install opensll opensll-devel 安装第三方模块./configure --prefix=/usr/local/nginx --add-module=/usr/local/src/ngx_http_consistent_hash-master/ make &amp;&amp; make install(最好先关掉nginx，不然会有oldpid文件产生) 注意：配置一模一样，然后–add-module 使用nginx脚本 nginx -s reload，重载 nignx， 启动 nginx -s stop，等效kill -INT pid nignx -t，配置文件正确测试 nignx -h，帮助 nginx -V，查看之前的编译选项 kill管理 kill -HUP pid，重载配置文件 kill -QUIT pid #优雅的关闭，等任务结束后再关闭 kill -USR1 pid #日志备份后，重新读取日志，等效./sbin/nginx -s reopend kill -USR2 pid #升级，配合-WINTCH 服务需要自己编写服务脚本加入/etc/init.d/下面 配置基本配置 worker_processes 1;#工作进程，一般设置为cpu*核数 events{ ，进程和链接的关系 worker_connections 1024;#一个woker可以1024个连接 http{ ，http的web服务器 server{ ，虚拟主机，最基本的配置 listen 80;#端口 server_name www.tingyiqu.com;#域名 location / {#网站根目录 root /data/blog/www/public;#可以用相对目录，相对/usr/local/nginx index index.html index.htm index.php;#没有文件名，默认读取，左到右顺序 autoindex on; 日志配置 access_log logs/access.log main; log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;; 注：作用范围可以放在server {}下，也可以放在全局下；重写uri过滤配置location，多个location时候精准匹配优先级最高其次，正则匹配最后，普通匹配ip地址相等，禁止访问 if ($remote_addr = 192.168.10.3) {return 403;} gzip压缩gzip on; #打开gzip_buffers 32 2k; #缓存输出gzip_comp_level 6; #6级压缩gzip_min_length 200; #200kgzip_types text/css text/xml application/x-javascript; #css，js，xml文件进行压缩，html默认注意mp3、图片等2进制不要压缩太小的文本文件不要压缩，不然还会变大；浏览器要告诉服务器支持什么压缩 缓存expire设置expires 10s;expires 30m;expires 1h;expires 30d; 注意作用域在location，主要对图片啥的进行缓存主要是对图片，js，css进行缓存服务器日期要正确 运维定时任务和日志切割的sh脚本 # !bin/bash LOCAL_PATH=/data/blog/logs/blog.access.log BASE_PATH=/data/blog/logs/$(date -d yesterday +%Y%m) mkdir -p $BASE_PATH mv $LOCAL_PATH $BASE_PATH/$(date -d yesterday +%Y%m%d%H%M).blog.access.log touch $LOCAL_PATH kill -USR1 `cat /usr/local/nginx/logs/nginx.pid` 应用反向代理与动静分离proxy_pass http://192.168.10.200:8080;动态脚本给php，静态的图片直接取负载均衡upstream 做反向代理做memecached负载均衡]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vagrant环境搭建]]></title>
    <url>%2Fpost%2Fb7b4a211.html</url>
    <content type="text"><![CDATA[下载 virtualBox网盘下载地址，提取码grs5 vagrant网盘下载地址，提取码cpvo 官方镜像下载地址，或者直接下载CentOS 7.2 x64 (Minimal, Puppet 4.2.3, Guest Additions 4.3.30) 安装virtualBox，vagrant安装直接点击下一步即可； 基本使用以上的准备工作完成后，就要撸起袖子开干了。 第一：在本地新建目录，作为vagrant的根目录 如：E:\vagrant\centos7.2 第二：导入刚刚下载的镜像(box文件) E:\vagrant\centos7.2&gt;vagrant box add centos7.2 E:/vagrant/box/centos7.2.box 第三：初始化box E:\vagrant\centos7.2&gt;vagrant init 此时，在E:\vagrant\centos7.2&gt;会自动生成Vagrantfile文件，修改文件中的box名称 config.vm.box = &quot;centos7.2&quot; 配置80端口映射到主机的80端口 config.vm.network &quot;forwarded_port&quot;, guest: 80, host: 80 第四：启动box E:\vagrant\centos7.2&gt;vagrant up 启动成功后，打开virtualBox，你会看到vagrant已经为我们搭建好了一个正在运行的centos7.2系统了： 第五：进入vagrant 可以在cmd命令下直接进入centos7.2，但我想没人能忍受在丑陋的cmd界面下使用linux E:\vagrant\centos7.2&gt;vagrant ssh 默认情况下，vagrant将/vagrant目录映射到物理主机的vagrant根目录，初始账号和密码都是是vagrant 遇到的问题# 第一个正常连接的 vagrant 环境的配置 $ vagrant ssh-config Host default ...... IdentityFile /Users/song/Downloads/vagrant/env_django/.vagrant/machines/default/virtualbox/private_key ...... # 登录异常的基于模板产生的 vagrant 环境 $ vagrant ssh-config Host default ...... IdentityFile /Users/song/.vagrant.d/insecure_private_key ...... 这里只贴出了不同的部分，所以我的想法就是把这个连接秘钥用正常环境的那个秘钥是否可以解决，所以在问题环境的 Vagrantfile 里增加如下配置 config.ssh.private_key_path = “config.ssh.private_key_path = “D:/vagrant_centos72/.vagrant/machines/default/virtualbox/private_key” private_key.txt下载，之后去掉txt后缀放到指定目录 再次启动虚拟环境，发觉再无报错，至此问题解决 另外好像还有个解决办法， 就是不指定用 key 连接，而是直接使用密码连接，虽然暴力，但是的确提供了一种思路 config.ssh.username = &quot;vagrant&quot; config.ssh.password = &quot;vagrant&quot;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vagrant</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql5.6.38安装]]></title>
    <url>%2Fpost%2F1f1783ef.html</url>
    <content type="text"><![CDATA[下载 下载不带boost库的源码 编译安装 cmake，make，make install `bashcmake . \-DCMAKE_INSTALL_PREFIX=/usr/local/lnmp/mysql5.6.38 \-DMYSQL_UNIX_ADDR=/tmp/mysql.sock \-DDEFAULT_CHARSET=utf8 \-DDEFAULT_COLLATION=utf8_general_ci \-DWITH_INNOBASE_STORAGE_ENGINE=1 \-DWITH_ARCHIVE_STORAGE_ENGINE=1 \-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \-DMYSQL_DATADIR=/usr/local/lnmp/mysql5.6.38/data \-DMYSQL_TCP_PORT=3306 \-DSYSCONFDIR=/usr/local/lnmp/mysql5.6.38/etc #以下几项在mysql5.7版本的时候需要补充，5.6版本只需要上面这些配置即可 -DDOWNLOAD_BOOST=1 \mysql5.7才需要 -DWITH_BOOST=/usr/local/boost \mysql5.7才需要 -DDOWNLOAD_BOOST_TIMEOUT=3600 #mysql5.7才需要 - `cmake可能的依赖` ```bash #cmake安装 yum install cmake #是字符终端下屏幕控制的基本库，你在TTY下登录到主机上mysql需要的 yum install ncurses-devel ncurses #警告Warning: Bison executable not found in PATH yum install bison #perl-Data-Dumper yum install perl-Data-Dumper #c++的标准库，提供很多必须的东西 yum install boost boost-doc boost-devel #编译工具 yum install gcc-c++ make的时候可能的问题 [ 74%] Building CXX object libmysql/CMakeFiles/libmysql.dir/libmysql_exports_file.cc.o make[2]: Warning: File `libmysql/libclientlib.a&#39; has modification time 0.082 s in the future Linking CXX shared library libmysqlclient.so CMake Error: cmake_symlink_library: System Error: Operation not supported CMake Error: cmake_symlink_library: System Error: Operation not supported make[2]: *** [libmysql/libmysqlclient.so.18.0.0] Error 1 make[1]: *** [libmysql/CMakeFiles/libmysql.dir/all] Error 2 make: *** [all] Error 2 {1} #该问题是由于在共享目录下编译，导致无权限创建链接不成功，换成本地目录重新编译即可成功 配置 复制配置文件 #进入编译目录，复制配置文件 cp support-files/my-default.cnf /etc/my.cnf 编辑配置文件 `ini For advice on how to change settings please seehttp://dev.mysql.com/doc/refman/5.6/en/server-configuration-defaults.html*** DO NOT EDIT THIS FILE. It’s a template which will be copied to the*** default location during install, and will be replaced if you*** upgrade to a newer version of MySQL.[mysql]#只能本地连接#bind-address = 127.0.0.1 [mysqld] user=mysqlsymbolic-links=0 Remove leading # and set to the amount of RAM for the most important datacache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.innodb_buffer_pool_size = 128MRemove leading # to turn on a very important data integrity option: loggingchanges to the binary log between backups.log_binThese are commonly set, remove the # and set as required.#安装目录basedir = /usr/local/lnmp/mysql5.6.38 #数据库配置datadir = /usr/local/lnmp/mysql5.6.38/data #端口port = 3306 #MySQL允许最大的进程连接数，如果经常出现Too Many Connections的错误提示，则需要增大此值。默认151max_connections = 3000 #设置每个主机的连接请求异常中断的最大次数，当超过该次数，MYSQL服务器将禁止host的连接请求，直到mysql服务器重启或通过flush hosts命令清空此host的相关信息。默认100max_connect_errors = 6000 #设置服务器级别的字符集，默认是latin1character-set-server=utf8 #统一设置默认的客户端，连接，返回的字符集default-character-set=utf8 server_id = …..#日志配置*ST**#1、错误日志,记录mysql运行错误信息#log-error = /usr/local/lnmp/mysql5.6.38/log/err.log #2、全查询日志,记录所有的查询语句#log_output = FILE#不启用的话慢日志查询会存在数据表中#general_log = on#general_log_file = /usr/local/lnmp/mysql5.6.38/log/query.log #3、慢查询日志，记录所有查询时间慢于某个值(long_query_time)的查询事件#slow_query_log = on#long_query_time = 0.5#slow_query_log_file = /usr/local/lnmp/mysql5.6.38//log/slow_query.log #4、二进制日志配置，第二、三行配置最后一个binlog-bin和binlog是不加后缀的文件名，不加后缀的话有妙用#server-id = 1#log_bin = /usr/local/lnmp/mysql5.6.38/log/log_bin/binlog-bin#log_bin_index = /usr/local/lnmp/mysql5.6.38//log/log_bin/binlog Remove leading # to set options mainly useful for reporting servers.The server defaults are faster for transactions and fast SELECTs.Adjust sizes as needed, experiment to find the optimal values.join_buffer_size = 128Msort_buffer_size = 2Mread_rnd_buffer_size = 2M sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES [mysqld_safe] #建议配置，可以看启动过程中的一些问题好排查问题 log-error=/usr/local/lnmp/mysql5.6.38/log/mysqld.log pid-file=/var/run/mysqld/mysqld.pid ## 初始化数据库 - v5.6版本 ```bash #在编译目录下执行（账号root,产生空密码） #--basedi安装目录,--datadir数据库目录 ./scripts/mysql_install_db \ --user=mysql \ --basedir=/usr/local/lnmp/mysql5.6.38 \ --datadir=/usr/local/lnmp/mysql5.6.38/data v5.7版本初始化 #在编译目录下执行（账号root,产生空密码） #--basedir安装目录 #--datadir数据库目录，得改为mysql用户所有目录 ./mysqld \ --initialize-inscure \ --user=mysql \ --basedir=/usr/local/mysql \ --datadir=/usr/local/mysql/data 这个步骤可能的问题 FATAL ERROR: please install the following Perl modules before executing ./scripts/mysql_install_db: Data::Dumper #yum -y install autoconf 加入服务 复制服务脚本到开机自启 #在编译目录下 cp support-files/mysql.server /etc/init.d/mysqld 添加可执行权限 chmod +x /etc/init.d/mysqld 添加服务 chkconfig --add mysqld 添加用户组和用户 添加用户组 groupadd mysql 添加用户 #-r表示不可登录的用户 useradd -r -g mysql mysql 启动service mysql start 启动时候遇到的问题 Starting MySQL.190307 14:52:11 mysqld_safe Directory &#39;/var/lib/mysql&#39; for UNIX socket file don&#39;t exists #没有配置文件的问题 log-error set to &#39;/var/log/mariadb/mariadb.log&#39;, however file don&#39;t exists #创建即可，并且设置为mysql用户组合]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql的ddl]]></title>
    <url>%2Fpost%2Fe7de59c5.html</url>
    <content type="text"><![CDATA[权限修改GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;your_mysql_password&#39; WITH GRANT OPTION; 数据库创建create database `erp_pro_line` default character set utf8mb4 collate utf8mb4_unicode_ci; 删除DROP database `erp_pro_line`; 表修改列#修改表的列 ALTER TABLE `erp_inbound_product` MODIFY COLUMN `price` decimal(14,8) NULL DEFAULT NULL COMMENT &#39;单价&#39; AFTER `weight`;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim常用命令]]></title>
    <url>%2Fpost%2F8c31560b.html</url>
    <content type="text"><![CDATA[命令 vim +10 fileName,第10行打开文件 vim -R file，只读的模式打开 编辑命令模式 i ，进入插入模式，前面插入 v，进入视图模式选择 y，复制 d，删除，dH 删除到头，dG删除到文件末尾 p，光标后面黏贴 ctrl+Z ，暂停回到shell，fg恢复回去，不区分大小写 ctrl+F，向前滚动一屏 ctrl+B，向后滚动一屏 . ，重复执行该命令 0，跳到行首 $，跳到行尾 1G，跳到第一行,区分大小写 G，跳到最后一行 /words，搜索单词（n， 往后查找；N，往前查找） u撤销 ctrl+r恢复 cc，编辑一行 dd，删除一行 yy，复制一行 esc ，回到命令模式 ggdG，删除文件所有内容 其中，gg为跳转到文件首行；dG为删除光标所在行以及其下所有行的内容； 再细讲，d为删除，G为跳转到文件末尾行； ex模式 :q，未更改退出 :e!，编辑恢复到最新保存的那个状态 :q!，退出不保存 :w，保存不退出，不要轻易保存 :wq,保存退出 :w /b.txt，另存为 :! ls，执行linux命令 :set nu,设置行号 :set ff，查看编码格式 :set ff=unix，设置编码格式 :set paste, 取消黏贴被注释的功能]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql常用命令]]></title>
    <url>%2Fpost%2F4ab1a8de.html</url>
    <content type="text"><![CDATA[#mysql导入 mysql -h localhost -P 3306 -u root -p erp_std_line &lt; C:\Users\Administrator\Desktop\aldb_erp_1024.sql #sql文件中不包含创建数据库的语句 mysql -h localhost -P 3306 -u root -p &lt; C:\Users\Administrator\Desktop\aldb_erp_1024.sql #sql文件中包含创建数据库的语句 #mysql导出 mysqldump -h localhost -u root -p 数据库名 &gt; c:/a.sql #表结构及数据 mysqldump -h localhost -u root -p -d 数据库名 &gt; c:/a.sql #只导出表结构 mysqldump -h localhost -u root -p --database 数据库名 --tables 表名 &gt; c:/a.sql #导出一个表的表结构及数据 mysqldump -h localhost -u root -p -d --database 数据库名 --tables 表名 &gt; c:/a.sql #只导出一个表的表结构 #创建数据库 create database `erp_pro_line` default character set utf8mb4 collate utf8mb4_unicode_ci; #删除数据库 DROP database `erp_pro_line`; #查看进程 show processlist]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmd常用命令]]></title>
    <url>%2Fpost%2F65edf23c.html</url>
    <content type="text"><![CDATA[ipconfig查看，ip地址 telnet连接到ip地址，http协议默认是80端口，可以打开端口 # 连接memcached telnet 127.0.0.1 11211 ctrl+]可打开回显功能，输入的即可直接显示，再按enter建可以隐藏 CD命令进行切换目录；切换目录直接输入盘符D:;切换目录并且改变盘符，要加/D参数，例如： cd /D D:\phpstudy\ tasklist查看进程列表，例如 tasklist | findstr processName taskkill杀死进程(帮助taskkill /?),F:强行关掉，T：包括子进程，IM：通过进程名称，例如： taskkill /F /T /IM 进程名称 dir查看目录 sc操作服务的，例如： sc delete 服务名称 start启动程序，例如： # 后台启动进程 start /b 命令 clsCMD清屏 net服务相关的命令，例如： #启动服务 net start 服务名 del删除，例如 del fileName set临时设置环境变量，例如： # 添加path set path=%path%;D:\wnmp\php5.6_nts setx永久设置环境变量，例如： # 添加path setx path=%path%;D:\wnmp\php5.6_nts netstat查看端口网络端口状态，例如 # 监听80端口 netstat -ano|findstr :80]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php数组-使用说明]]></title>
    <url>%2Fpost%2Fedbab175.html</url>
    <content type="text"><![CDATA[ksort/** * 【主要用于将数组整理一个有序的数组，比如接口签名时候，对参数数组进行排序】 * * 对数组按照键名升序排序，通过引用的方式直接改变原来的数组 * 本函数主要用于关联数组，因为关联数组已经是升序了 * * @return boolean 成功时返回 TRUE，或者在失败时返回FALSE。 */ call_user_func(function () { $arr = [ &#39;a&#39; =&gt; 1, &#39;c&#39; =&gt; 3, &#39;b&#39; =&gt; 2, ]; //@var $arr 输入数组&amp;$arr， /** * SORT_REGULAR - 正常比较单元（不改变类型） * SORT_NUMERIC - 单元被作为数字来比较 * SORT_STRING - 单元被作为字符串来比较 * SORT_LOCALE_STRING - 根据当前的区域（locale）设置来把单元当作字符串比较，可以用 setlocale() 来改变。 * SORT_NATURAL - 和 natsort() 类似对每个单元以“自然的顺序”对字符串进行排序。 PHP 5.4.0 中新增的。 * SORT_FLAG_CASE - 能够与 SORT_STRING 或 SORT_NATURAL 合并（OR 位运算），不区分大小写排序字符串。 */ $return = ksort($arr, SORT_REGULAR); }); array_map/** * 【以现有的数组中的数据为基础，加工整理新的映射数组结构】 * * @renturn 数组 */ call_user_func(function () { //单个数组，$val就是该数组的值 function cube($val) { return ($val * $val * $val); } $arr = [1, 2, 3, 4, 5]; $returnRes = array_map(&quot;cube&quot;, $arr); //多个数组， /** * 最好参数的数量和数组的数量要对应上，遍历数组元素最多次数，缺少为null * * @param $arrayi1EleVal 1, 2, 3, 4, 5 * @param $array2EleVal &quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;, &quot;cuatro&quot;, &quot;cinco&quot; * @return string */ function show_Spanish($arrayi1EleVal, $array2EleVal) { return (&quot;The number $arrayi1EleVal is called $array2EleVal in Spanish&quot;); } $array1 = array(1, 2, 3, 4, 5); $array2 = array(&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;, &quot;cuatro&quot;, &quot;cinco&quot;); $res = array_map(&quot;show_Spanish&quot;, $array1, $array2); }); array_walk/** * 【比较适合用在遍历业务逻辑，把业务逻辑封装在回调函数里】 * * 相对于foreach主要用于遍历数据结构比较适合 */ call_user_func(function () { $fruits = [ &quot;d&quot; =&gt; &quot;lemon&quot;, &quot;a&quot; =&gt; &quot;orange&quot;, &quot;b&quot; =&gt; &quot;banana&quot;, &quot;c&quot; =&gt; &quot;apple&quot;, ]; /** * @param $val 第一个参数可以直接引用，来改变数组本身 * @param $key 键值 * @param $prefix 前缀 */ function test_alter(&amp;$val, $key, $prefix) { $val = &quot;$val: $val&quot;; } //第三个参数传给回调函数的$prefix array_walk($fruits, &#39;test_alter&#39;, &#39;extraData&#39;); }); array_walk_recursive/** * 【主要用在遍历含有子数组的时候】 * * 相对于foreach的优点是可以递归所有子数组 * 签名的时候，拼接含有子数组的参数为字符串的时候很有用 */ call_user_func(function () { $fruits = [ &#39;sweet&#39; =&gt; [//sweet key将不会传进回调 &#39;a&#39; =&gt; &#39;apple&#39;, &#39;b&#39; =&gt; &#39;banana&#39;, ], &#39;sour&#39; =&gt; &#39;lemon&#39;, ]; function test_print(&amp;$val, $key) { $val = &quot;$key ： $val&quot;; } array_walk_recursive($fruits, &#39;test_print&#39;); }); array_filter/** * 【主要用于过滤】 * * 将key，val传递给回调喊，筛选数组， * 如果回调函数返回true则返回，否则被移除 */ call_user_func(function () { //没有回调过滤，去除数组中值转为布尔值为false的，可以去除0，&#39;&#39;等 $arr = [&quot;a&quot; =&gt; 0, &quot;b&quot; =&gt; false, &quot;c&quot; =&gt; &#39;&#39;, &quot;d&quot; =&gt; 4, &quot;e&quot; =&gt; 5]; $resArr = array_filter($arr); //接受值作为的唯一参数 function odd($val) { return ($val &amp; 1); } $arr = [&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2, &quot;c&quot; =&gt; 3, &quot;d&quot; =&gt; 4, &quot;e&quot; =&gt; 5]; $resArr = array_filter($arr, &quot;odd&quot;); //接受键名和值作为的参数 function odd1($val, $key) { return ($val &amp; 1); } $arr = [&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2, &quot;c&quot; =&gt; 3, &quot;d&quot; =&gt; 4, &quot;e&quot; =&gt; 5]; $resArr = array_filter($arr, &quot;odd1&quot;, ARRAY_FILTER_USE_BOTH); //接受键名作为的唯一参数 function odd2($key) { return ($val &amp; 1); } $arr = [&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2, &quot;c&quot; =&gt; 3, &quot;d&quot; =&gt; 4, &quot;e&quot; =&gt; 5]; $resArr = array_filter($arr, &quot;odd2&quot;, ARRAY_FILTER_USE_KEY); }); 堆栈操作/** * 堆栈操作 */ call_user_func(function () { $arr = [1]; $returnRes = array_push($arr, 2);//栈顶加入,追加在后面,$arr = [1,2] $returnRes = array_pop($arr);//栈顶弹出，后面剔除,$arr = [1] $arr = [1]; $returnRes = array_unshift($arr, 2);//栈底加入，追加到前面，索引重新编排，$arr = [2,1] $returnRes = array_shift($arr);//栈底弹出，前面剔除，索引重新编排,$arr = [1] }); uasort/** * 主要是二维数组自定义排序， * 优点：索引值不会受到影响 */ call_user_func(function () { $arr = [ [&#39;name&#39; =&gt; &#39;张三&#39;, &#39;score&#39; =&gt; 98], [&#39;name&#39; =&gt; &#39;李四&#39;, &#39;score&#39; =&gt; 99], [&#39;name&#39; =&gt; &#39;王五&#39;, &#39;score&#39; =&gt; 96], ]; $returnRes = uasort($arr, function ($currentArr, $previousArr) { if ($currentArr[&#39;score&#39;] == $previousArr[&#39;score&#39;]) { return 0; } //当前的比上一个大则交换位置（降序），-1：交换位置，1位置不变 return $currentArr[&#39;score&#39;] &gt; $previousArr[&#39;score&#39;] ? -1 : 1; }); }); array_multisort/** * 【用于对多个数组进行排序，后面的数组会先跟随前面的数组排序后再按自身的规则排序】 * * 无限维数组排序 * 基于列一样的排序形式，第一数组参数为第一列 * 第一个列优先级别 &gt; 第二列 &gt; 第三列... * 缺点：关联（string）键名保持不变，但数字键名会被重新索引 */ call_user_func(function () { $arr = [//列1 [&#39;name&#39; =&gt; &#39;张三&#39;, &#39;score&#39; =&gt; 98], [&#39;name&#39; =&gt; &#39;李四&#39;, &#39;score&#39; =&gt; 99], [&#39;name&#39; =&gt; &#39;王五&#39;, &#39;score&#39; =&gt; 96], ]; foreach ($arr as $key =&gt; $row) { $score[$key] = $row[&#39;score&#39;];//列2 $name[$key] = $row[&#39;name&#39;];//列3 } //排序多个数组 //$score先按分数降序排序-&gt;$name跟随$score的顺序然后按名字升序排序-&gt;$arr跟随$name的顺序 $returnRes = array_multisort($score, SORT_DESC, $name, SORT_ASC, $arr); //数组，排序顺序，排序类型标志 /** * 排序类型标志: * SORT_REGULAR - 正常比较单元（不改变类型） * SORT_NUMERIC - 单元被作为数字来比较 * SORT_STRING - 单元被作为字符串来比较 * SORT_LOCALE_STRING - 根据当前的区域（locale）设置来把单元当作字符串比较，可以用 setlocale() 来改变。 * SORT_NATURAL - 和 natsort() 类似对每个单元以“自然的顺序”对字符串进行排序。 PHP 5.4.0 中新增的。 * SORT_FLAG_CASE - 能够与 SORT_STRING 或 SORT_NATURAL 合并（OR 位运算），不区分大小写排序字符串。 */ // $returnRes = array_multisort($score, SORT_DESC, SORT_REGULAR, $name, SORT_ASC, SORT_REGULAR, $arr); });]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx配置访问密码]]></title>
    <url>%2Fpost%2Fb8b76378.html</url>
    <content type="text"><![CDATA[如果我们在 nginx 下搭建了一些站点，但是由于站点内容或者流量的关系，我们并不想让所有人都能正常访问，那么我们可以设置访问认证。只有让用户输入正确的用户名和密码才能正常访问。效果如下： 在 nginx 下，提供了 ngx_http_auth_basic_module 模块实现让用户只有输入正确的用户名密码才允许访问web内容。默认情况下，nginx 已经安装了该模块。所以整体的一个过程就是先用第三方工具设置用户名、密码（其中密码已经加过密），然后保存到文件中，接着在 nginx 配置文件中根据之前事先保存的文件开启访问验证。 生成密码可以使用 htpasswd，或者使用 openssl 。下面以 htpasswd 为例。 1.安装 htpasswd 工具这里直接 yum 进行安装，你也可根据需要选择编译安装： [root@uuu ~]# yum -y install httpd-tools 设置用户名和密码，并把用户名、密码保存到指定文件中： [root@uuu ~]# htpasswd -c /usr/local/src/nginx/passwd coderschool New password: Re-type new password: Adding password for user coderschool 注意：上面的 /usr/local/src/nginx/passwd 是生成密码文件的路径，然后 coderschool 是用户名，你可以根据需要自行设置成其它用户名。运行命令后，会要求你连续输入两次密码。输入成功后，会提示已经为 conerschool 这个用户添加了密码。 我们可以看下最后生成的密码文件的内容： [root@uuu ~]# cat /usr/local/src/nginx/passwd coderschool:$apr1$DhlW8hIu$BXyCQ7hiEos1DiqgwEYcZ1 其中用户名就是 coderschool ，分号后面就是密码（已经加过密）。 2.修改 nginx 配置文件找到 nginx 配置文件，因为我们要对整个站点开启验证，所以在配置文件中的第一个server修改如下： server { listen 80; server_name localhost; ....... #新增下面两行 auth_basic &quot;Please input password&quot;; #这里是验证时的提示信息 auth_basic_user_file /usr/local/src/nginx/passwd; location /{ ....... } 然后重启 nginx： [root@uuu sbin]# ./nginx -t nginx: the configuration file /usr/local/src/nginx/conf/nginx.conf syntax is ok nginx: configuration file /usr/local/src/nginx/conf/nginx.conf test is successful [root@uuu sbin]# ./nginx -s reload 以上都配置无误后，你重新访问你的站点，如果出现需要身份验证的弹窗就说明修改成功了。下面介绍 htpasswd 命令的一些参数。 3.htpasswd选项参数htpasswd [-cmdpsD] passwordfile username htpasswd -b[cmdpsD] passwordfile username password htpasswd -n[mdps] username htpasswd -nb[mdps] username password htpasswd命令选项参数说明-c 创建一个加密文件-n 不更新加密文件，只将htpasswd命令加密后的用户名密码显示在屏幕上-m 默认htpassswd命令采用MD5算法对密码进行加密-d htpassswd命令采用CRYPT算法对密码进行加密-p htpassswd命令不对密码进行进行加密，即明文密码-s htpassswd命令采用SHA算法对密码进行加密-b htpassswd命令行中一并输入用户名和密码而不是根据提示输入密码-D 删除指定的用户 htpasswd例子a、如何利用htpasswd命令添加用户？ htpasswd -bc ./.passwd tonyzhang pass 在当前目录下生成一个.passwd文件，用户名tonyzhang ，密码：pass，默认采用MD5加密方式 b、如何在原有密码文件中增加下一个用户？ htpasswd -b ./.passwd onlyzq pass 去掉c选项，即可在第一个用户之后添加第二个用户，依此类推 c、如何不更新密码文件，只显示加密后的用户名和密码？ htpasswd -nb tonyzhang pass 不更新.passwd文件，只在屏幕上输出用户名和经过加密后的密码 d、如何利用htpasswd命令删除用户名和密码？ htpasswd -D .passwd tonyzhang e、如何利用 htpasswd 命令修改密码？ htpasswd -D .passwd tonyzhanghtpasswd -b .passwd tonyzhang pass]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql实例]]></title>
    <url>%2Fpost%2F790dc092.html</url>
    <content type="text"><![CDATA[主要整理一些工作中常用的，随时碰到的sql应用场景； 查找字段重复的记录 通过子表查询来实现：可以查找具体重复几次的，或者大于某个次数的记录，只要修改count(*) 的条件即可 SELECT customer_id FROM `saas_statement_customer` WHERE customer_id IN ( SELECT customer_id FROM saas_statement_customer GROUP BY customer_id HAVING count(*) = 2 ) ORDER BY customer_id DESC; 用一条SQL 语句 查询出每门课都大于80 分的学生姓名 在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用 -- 方案一，通过子表查找出分数小于80分的学生，然后排除掉这些即是 select distinct student_name from table_test_one where student_name not in (select distinct student_name from table_test_one where score&lt;=80); -- 方案二，通过按学生名字进行分组，然后找出最低分数大于80分的学生就是 select student_name from table_test_one group by student_name having min(score)&gt;80; 删除除了id不同, 其他都相同的学生冗余信息 GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组。刚刚就是GROUP BY 对多列的使用场景 -- 利用group by找出除了id以为其它字段都相等的字段的记录，然后删除id最小的row DELETE table_test_one WHERE id NOT IN ( SELECT min(id) FROM table_test_one GROUP BY student_no, student_name, subject_no, subject_name, score HAVING count(*) &gt; 1 ); 行转列 在统计的是，希望统计1991年1月份的数量是多少，这种场景就和需要； 表数据如下： 转变如下： select year, (select amount from table_test_two t where t.month = 1 and t.year = table_test_two.year) as month1, (select amount from table_test_two t where t.month = 2 and t.year = table_test_two.year) as month2, (select amount from table_test_two t where t.month = 3 and t.year = table_test_two.year) as month3 from table_test_two group by year; 复制表 如果需要将数据也复制过去，则上面改成where 1=1 -- 只复制结构, 源表名：table_test_two 新表名：table_test_three create table table_test_three as select * from table_test_two where 1=2; 复制表数据 将表 table_test_two 的数据复制到表table_test_three 里面 INSERT INTO table_test_three (year, month, amount) -- 查找出数据的字段，插入到table_test_three SELECT year, month, amount FROM table_test_two; 两张关联表，删除主表中已经在副表中没有的信息 DELETE FROM table_test_student WHERE -- 利用not exists 判断是否存在，返回布尔值 NOT EXISTS ( SELECT * FROM table_test_class WHERE table_test_student.class_id = table_test_class.calss_id );]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome开发者工具的小技巧]]></title>
    <url>%2Fpost%2F40c1d23c.html</url>
    <content type="text"><![CDATA[CHROME开发者工具的小技巧Chrome的开发者工具是个很强大的东西，相信程序员们都不会陌生，不过有些小功能可能并不为大众所知，所以，写下这篇文章罗列一下可能你所不知道的功能，有的功能可能会比较实用，有的则不一定，也欢迎大家补充交流。 话不多话，我们开始。 代码格式化有很多css/js的代码都会被 minify 掉，你可以点击代码窗口左下角的那个 { } 标签，chrome会帮你给格式化掉。 强制DOM状态有些HTML的DOM是有状态的，比如 标签，其会有 active，hover， focus，visited这些状态，有时候，我们的CSS会来定关不同状态的样式，在分析网页查看网页上DOM的CSS样式时，我们可以点击CSS样式上的 :hov 这个小按钮来强制这个DOM的状态。 动画 现在的网页上都会有一些动画效果。在Chrome的开发者工具中，通过右上角的菜单中的 More Tools =&gt; Animations 呼出相关的选项卡。于是你就可以慢动作播放动画了（可以点选 25% 或 10%），然后，Chrome还可以帮你把动画录下来，你可以拉动动再画的过程，甚至可以做一些简单的修改。 直接编辑网页在你的 console 里 输入下面的命令： `document.designMode = ``&quot;on&quot;` 于是你就可以直接修改网页上的内容了。 P.S. 下面这个抓屏中还演示了一个如何清空console的示例。你可以输入 clear() 或是 按 Ctrl+L（Windows下），CMD + K (Mac下) 网络限速你可以设置你的网络的访问速度来模拟一个网络很慢的情况。 复制HTTP请求这个是我很喜欢 的一个功能，你可以在 network选项卡里，点击 XHR 过滤相关的Ajax请求，然后在相关的请求上点鼠标右键，在菜单中选择： Copy =&gt; Copy as cURL，然后就可以到你的命令行下去 执行 curl 的命令了。这个可以很容易做一些自动化的测试。 友情提示：这个操作有可能会把你的个人隐私信息复制出去，比如你个人登录后的cookie。 抓个带手机的图 这个可能有点无聊了，不过我觉得挺有意思的。 在device显示中，先选择一个手机，然后在右上角选 Show Device Frame，然后你就看到手机的样子了，然后再到那个菜中中选 Capture snapshot，就可以抓下一个有手机样子的截图了。 我抓的图如下（当然，不是所有的手机都有frame的） 设置断点除了给Javascript的源代码上设置断点调试，你还可以： 给DOM设置断点选中一个DOM，然后在右键菜单中选 Break on … 你可以看到如下三个选项： 给XHR和Event Lisener设置断点在 Sources 面页中，你可以看到右边的那堆break points中，除了上面我们说的给DOM设置断点，你还可以给XHR和Event Listener设置断点，载图如下： 关于Console中的技巧DOM操作 chrome会帮你buffer 5个你查看过的DOM对象，你可以直接在Console中用 $0, $1, $2, $3, $4来访问。 你还可以使用像jQuery那样的语法来获得DOM对象，如：$(&quot;#mydiv&quot;) 你还可使用 $$(&quot;.class&quot;) 来选择所有满足条件的DOM对象。 你可以使用 getEventListeners($(&quot;selector&quot;)) 来查看某个DOM对象上的事件（如下图所示）。 你还可以使用 monitorEvents($(&quot;selector&quot;)) 来监控相关的事件。比如： `monitorEvents(document.body, ``&quot;click&quot;``);` Console中的一些函数1）monitor函数 使用 monitor函数来监控一函数，如下面的示例 2）copy函数 copy函数可以把一个变量的值copy到剪贴板上。 3）inspect函数 inspect函数可以让你控制台跳到你需要查看的对象上。如： 更多的函数请参数官方文档 – Using the Console / Command Line Reference Console的输出我们知道，除了console.log之外，还有console.debug，console.info，console.warn，console.error这些不同级别的输出。另外一个鲜为人知的功能是，console.log中，你还可以对输出的文本加上css的样式，如下所示： `console.log(``&quot;%c左耳朵&quot;``, ``&quot;font-size:90px;color:#888&quot;``)` 于是，你可以定义一些相关的log函数，如： `console.todo = ``function``( msg){`` ``console.log( ``&#39;%c%s %s %s&#39;``, ``&#39;font-size:20px; color:yellow; background-color: blue;&#39;``, ``&#39;--&#39;``, msg, ``&#39;--&#39;``);``}``console.important = ``function``( msg){`` ``console.log( ``&#39;%c%s %s %s&#39;``, ``&#39;font-size:20px; color:brown; font-weight: bold; text-decoration: underline;&#39;``, ``&#39;--&#39;``, msg, ``&#39;--&#39;``);``}` 关于console.log中的格式化，你可以参看如下表格： 指示符 输出 %s 格式化输出一个字符串变量。 %i or %d 格式化输出一个整型变量的值。 %f 格式化输出一个浮点数变量的值。 %o 格式化输出一个DOM对象。 %O 格式化输出一个Javascript对象。 %c 为后面的字符串加上CSS样式 除了console.log打印js的数组，你还可以使用console.table来打印，如下所示： `var` `pets = [`` ``{ animal: ``&#39;Horse&#39;``, name: ``&#39;Pony&#39;``, age: 23 },`` ``{ animal: ``&#39;Dog&#39;``, name: ``&#39;Snoopy&#39;``, age: 13 },`` ``{ animal: ``&#39;Cat&#39;``, name: ``&#39;Tom&#39;``, age: 18 },`` ``{ animal: ``&#39;Mouse&#39;``, name: ``&#39;Jerry&#39;``, age: 12}``];``console.table(pets)` 关于console对象 console对象除了上面的打日志的功能，其还有很多功能，比如： console.trace() 可以打出js的函数调用栈 console.time() 和 console.timeEnd() 可以帮你计算一段代码间消耗的时间。 console.profile() 和 console.profileEnd() 可以让你查看CPU的消耗。 console.count() 可以让你看到相同的日志当前被打印的次数。 console.assert(expression, object) 可以让你assert一个表达式 这些东西都可以看看Google的Console API的文档。 其实，还有很多东西，你可以参看Google的官方文档 – Chrome DevTools 关于快捷键点击在 DevTools的右上角的那三个坚排的小点，你会看到一个菜单，点选 Shortcuts，你就可以看到所有的快捷键了 如果你知道更多，也欢迎补充！]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmder使用]]></title>
    <url>%2Fpost%2F25c5187c.html</url>
    <content type="text"><![CDATA[原因使用cmder而不使用gitbash的原因是，git的bin目录下的bash程序嵌入到phpstorm的terminal的时候，对应utf-8的编码会乱码，暂时还没有找到一个可以解决的方法； 而cmder有git的功能，并且可以较好的显示utf-8的编码字符，所有可以使用； 搭建环境安装直接解压到某个目录就可以了，点击Cmder.exe运行。 配置环境变量在系统变量添加 变量名： CMDER_HOME 变量值： 安装绝对路径 添加 cmder 到右键菜单配置环境变量后，以管理员权限权限打开cmd终端，然后执行 ​ 配置好后，任意文件夹右键 新标签打开个管理员权限终端快捷键 Ctrl + t 后勾选 解决中文乱码问题chcp 65001，设置utf-8的编码，这个也是我用cmder的核心功能 设置默认为cmd因为bash的话，嵌入phpstorm的是，utf-8编码无法显示 嵌入phpstorm&quot;cmd.exe&quot; /k &quot;%CMDER_ROOT%\vendor\init.bat&quot;，如果utf8在控制台出现乱码，可以用chcp 65001命令即可，将当前编码切换到utf-8；如果使用gitbash的话，没有相关的命令来解决。如果直接使用cmd的话，对git不是很友好，看不到在哪个分支，所有还是用cmder最后为好； 解决文字重叠问题**Win + ALT + P 唤出设置界面 &gt; mian &gt; font &gt; monospce,去掉那勾勾即可 修改cmder命令提示符为$不仅修改$，还解决向上翻页历史记录多出一个字符的问题。进入解压后的cmder的目录，进入vendor,打开clink.lua，找到第41行修改前 local cmder_prompt = &quot;\x1b[1;32;40m{cwd} {git}{hg} \n\x1b[1;30;40m{lamb} \x1b[0m&quot; 修改为 local cmder_prompt = &quot;\x1b[1;32;40m{cwd} {git}{hg} \n\x1b[1;30;40m$ \x1b[0m&quot; 修改保存后，重启cmder 常用功能介绍 如上图示编号的部分说明如下： 1, Cmder常用快捷键 利用Tab，自动路径补全； 利用Ctrl+T建立新页签；利用Ctrl+W关闭页签; 利用Ctrl+Tab切换页签; Alt+F4：关闭所有页签 Alt+Shift+1：开启cmd.exe Alt+Shift+2：开启powershell.exe Alt+Shift+3：开启powershell.exe (系统管理员权限) Ctrl+1：快速切换到第1个页签 Ctrl+n：快速切换到第n个页签( n值无上限) Alt + enter： 切换到全屏状态； Ctr+r 历史命令搜索 2, 可在视窗内搜寻画面上出现过的任意关键字。 3, 新增页签按钮。 4, 切换页签按钮。 5, 锁定视窗，让视窗无法再输入。 6, 切换视窗是否提供卷轴功能，启动时可查询之前显示过的内容。 7, 按下滑鼠左键可开启系统选单，滑鼠右键可开启工具选项视窗。 Win+Alt+P ：开启工具选项视窗。 优点 Cmder还增加了alias功能;他让你用短短的指令执行一些常见但指令超长又难以记忆的语法;比如 ls cls等等；在其控制台输入alias可以查看。 主控台文字自动放大缩小功能，你只要按下Ctrl+滑鼠滚轮就可以办到;果你用支援两点触控的笔电，也可以在触控板上用两指放大的手势调整文字大小。还有：up，向上翻历史命令; Cmder有极为简单的复制粘贴操作。Ctr+V直接粘贴;用鼠标选中你想拷贝的内容，自动就复制到剪切板；天神，这悉数的美感;点赞! 自定义aliases:打开Cmder目录下的config文件夹，里面的user_aliases.cmd文件就是我们可以配置的别名文件，该别名只适用于cmd，例如： cmderr=cd /d &quot;%CMDER_ROOT%&quot; cdwnmp=cd /d E:\wnmp cdmysql=cd /d E:\wnmp\mysql\mysql5.6\bin cdnginx=cd /d E:\wnmp\nginx cdredis=cd /d E:\wnmp\redis cdmemcached=cd /d E:\wnmp\memcached cdnode=cd /d E:\wnmp\node cdwww=cd /d E:\www cdo2o=cd /d E:/www/o2orepair_dev cdhexo=cd /d E:\www\hexo cddocker=cd /d E:\www\docker]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>cmder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git子模块]]></title>
    <url>%2Fpost%2F2d353c21.html</url>
    <content type="text"><![CDATA[意义git 的子模块（git submodule）功能（你在你的 git 项目里 clone 的别人的项目）。 在你的主项目的 git 库里，子模块只是一个 HEAD 指针，指向子模块的 commit。 这个功能的意义： 在这里，如果你需要修改 next 主题（可能需要很多文件），又想保证能够随时更新最新版本，其实用子模块功能是很方便的。 只需要 clone 下来新建一个 branch，用来自己用，每次官方更新 pull 到另一个分支，merge 一下就行。 相当于把一个大项目分成多个小项目，尽可能减少项目之间的关联，方便调试和修改。 删除git rm --cached themes\maupassant\ 如果不删除的话，修改该项目里的内容，将不会被提交到主项目中]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓开发环境搭建]]></title>
    <url>%2Fpost%2F79626d9d.html</url>
    <content type="text"><![CDATA[下载JDK 链接：https://pan.baidu.com/s/1sd-qedXETWXv7c3RS6iTPw提取码：e1ie 配置Windows上JDK的变量环境为了配置JDK的系统变量环境，我们需要设置三个系统变量，分别是JAVA_HOME，Path和CLASSPATH。下面是这三个变量的设置防范。 JAVA_HOME 先设置这个系统变量名称，变量值为JDK在你电脑上的安装路径：C:\Program Files\Java\jdk1.8.0_20。创建好后则可以利用%JAVA_HOME%作为JDK安装目录的统一引用路径。 Path PATH属性已存在，可直接编辑，在原来变量后追加：;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin 。 CLASSPATH 设置系统变量名为：CLASSPATH 变量值为：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar 。 注意变量值字符串前面有一个”.”表示当前目录，设置CLASSPATH 的目的，在于告诉Java执行环境，在哪些目录下可以找到您所要执行的Java程序所需要的类或者包。 下载安装Eclipse 链接：https://pan.baidu.com/s/14dktyEDipqMC9RG7pZl90A提取码：anvm 下载安装Android SDK 链接：https://pan.baidu.com/s/1EvIXlcuH9deWodL5Un3zgg提取码：mx54 配置了JDK变量环境，安装好了Eclipse，这个时候如果只是开发普通的JAVA应用程序，那么Java的开发环境已经准备好了。我们要通过Eclipse来开发Android应用程序，那么我们需要下载Android SDK（Software Development Kit）和在Eclipse安装ADT插件，这个插件能让Eclipse和Android SDK关联起来。 安装ADT插件打开Eclipse，依次选择 Help &gt; Install New Software &gt; Add 。 名称填写 ADT Plugin地址填写 https://dl-ssl.google.com/android/eclipse/]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows的git bash设置永久别名]]></title>
    <url>%2Fpost%2F29ef2bf9.html</url>
    <content type="text"><![CDATA[通过右键菜单，打开git bash 比如现在想要让grep命令能够给筛选出的文本添加颜色，要运行命令grep –color 键入命令： cd /etc/profile.d vim aliases.sh # 编辑aliases文件 在里面加上下面这行，保存并退出该文件。重新打开git bash就可以了]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>gitBash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpStorm快捷键]]></title>
    <url>%2Fpost%2Fa986cf0f.html</url>
    <content type="text"><![CDATA[Editing 按键 说明 Ctrl + Space Basic code completion Alt + Enter Show intention actions and quick-fixes Ctrl + P Parameter info (within method call arguments) Ctrl + Q Quick documentation lookup Ctrl + mouse over code Brief Info Alt + Insert Generate code… (Getters, Setters,Constructors，phpdoc,copyRight) Ctrl + O Override methods Ctrl + I Implement methods Ctrl + Alt + T Surround with… (if..else, try..catch, for, etc.) Ctrl + / Comment/uncomment with line comment Ctrl + Shift + / Comment/uncomment with block comment Ctrl + W Select successively increasing code blocks Ctrl + Shift + W Decrease current selection to previous state Ctrl + Alt + L Reformat code Ctrl + Alt + I Auto-indent line(s) Ctrl + D Duplicate current line or selected block Ctrl + Y Delete line at caret Ctrl + X 剪切一行 Ctrl + Shift + J 把下一行合并到上一行的末尾 Ctrl + Enter Smart line split (HTML and JavaScript only Shift + Enter Start new line Ctrl + Shift + U Toggle case for word at caret or selected block Ctrl + Shift + ] / [ Select till code block end/start Ctrl + Delete Delete to word end Ctrl + Backspace Delete to word start Ctrl +/- Expand/collapse code block Ctrl + F4 Close active editor tab Ctrl + Shift + V Paste from history Tab/Shift + Tab 右缩进/左缩进 Ctrl + Shift + Up/Ctrl + Shift + Down 交换上行/交换下行，如果选择方法名，则是方法交换 Alt + J 选择下一个于被选中的文本一样的文本 Ctrl + Z/Ctrl + Shift + Z 撤销/取消撤销 Alt + M 驼峰转换，要安装插件：String Manipulation Ctrl + Shift + -/Ctrl + Shift + + 展开所有代码/收缩所有代码 Select Text + Mouse Left Key Move 移动选中文本 Ctrl + Select Text + Mouse Left Key Move 复制选中文本 Ctrl + Shift + C 复制文件路径 Ctrl + V 转义黏贴 Ctrl + Shift + V 选择黏贴 Ctrl + Shift + Alt + V 没有格式的黏贴 Alt + Shift + Up/Alt + Shift + Down 与上一块交换/与下一块交换（待验证） Debugging 按键 说明 F8 Step over F7 Step into Shift + F8 Step out F9 Resume program Ctrl + F8 Toggle breakpoint Ctrl+Shift+F8 View breakpoints Running 操作 说明 Shift + F10 Run Shift + F9 Debug Ctrl + Shift + F10 Run context configuration from editor Ctrl + Shift + X Run command line 搜索/替换 操作 说明 Ctrl + F/R Find/Replace F3/Shift + F3 Find next/previous Ctrl + Shift + F/R Find/Replace in path Usage Search 操作 说明 Alt + F7 / Ctrl + F7 Find usages / Find usages in file Ctrl + Shift + F7 Highlight usages in file Ctrl + Alt + F7 Show usages Ctrl + F12 显示/查找当前类的方法 Navigation 操作 说明 Ctrl + N Go to class（查找类） Ctrl + Shift + N Go to file（查找文件） Ctrl + Alt + Shift + N Go to symbol（查找方法，变量） Ctrl + G Go to line Alt + Right/Left Go to next/previous editor tab Esc Go to editor (from tool window) Ctrl + E Recent files popup Ctrl + Alt + Left/Right Navigate back/forward Ctrl + Shift + Backspace Navigate to last edit location Alt + F1 Select current file or symbol in any view（打开目录，改变的文件，文件的架构，） Ctrl + B or Ctrl + Click Go to declaration Ctrl + Alt + B Go to implementation(s) Ctrl + Shift + I Open quick definition lookup（显示方法的内容，不跳转到该方法） Ctrl + Shift + B Go to type declaration Ctrl + U Go to super-method/super-class Alt + Up/Down Go to previous/next method（看类里每个方法的功能的时候用） Ctrl + ] / [ Move to code block end/start F2 / Shift + F2 Next/previous highlighted error F4 / Ctrl + Enter Edit source / View source Ctrl + Home/Ctrl + End 跳到文件头/跳到文件尾 Refactoring 操作 说明 F5/F6 Copy/Move Alt + Delete Safe Delete Shift + F6 Rename Ctrl + Alt + N Inline Variable Ctrl + Alt + M/V/F/C Extract Method/Variable/Field/Constant Ctrl + Alt + Shift + T Refactor This (shows all available refactorings) VCS/Local History 操作 说明 Alt + BackQuote (`) ‘VCS’ quick popup Ctrl + K Commit project to VCS Ctrl + T Update project from VCS Alt + Shift + C View recent changes General 操作 说明 Double Shift Search everywhere Ctrl + Shift + A Find Action Alt + 1 显示隐藏项目目录 Alt + 2 断点、书签、收藏查看 Alt + 5 打开调试 Alt +7 显示隐藏当前类结构 Ctrl + Alt + F11 Toggle full screen mode Ctrl + Shift + F12 Toggle maximizing editor Alt + Shift + F Add to Favorites Alt + Shift + I Inspect current file with current profile Ctrl + Alt + S Open Settings dialog Ctrl + Tab Switch between tabs and tool window Alt +F12 打开控制台cmd Ctrl + F4 关闭当前选项卡 Ctrl + Tab 快速切换标签 Ctrl + F11 标记该行标签 Shift + F11 查看所有标记的标签内容 Ctrl + H 查看类的继承关系 Ctrl + Shift + Alt + Insert 新建草稿 Live Templates / Snippets 操作 说明 Ctrl + J Insert Live Template eco ‘echo’ statement fore foreach(iterable_expr as $value) {…} forek foreach(iterable_expr as $key =&gt; $value) {…} inc/inco ‘include’/‘include_once’ statement prif private function prof protected function pubf public function rqr/rqro ‘require’/‘require_once’ statement]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>phpStorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpstorm跳回快捷和windos屏幕旋转快捷冲突]]></title>
    <url>%2Fpost%2F5d3f8823.html</url>
    <content type="text"><![CDATA[禁用掉windos的屏幕旋转快捷键在桌面右键点击，选择屏幕分辨率 然后选择 然后 最后]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>phpStorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git在push的时候自动更新]]></title>
    <url>%2Fpost%2F6ed76400.html</url>
    <content type="text"><![CDATA[在hooks文件夹下新建立post-reive文件，写入下面内容即可 #!/bin/sh git --work-tree=/data/www/jizhang/ --git-dir=/data/gitroot/jizhang.git checkout -f]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitBash 中文乱码]]></title>
    <url>%2Fpost%2Fe7ccc5c2.html</url>
    <content type="text"><![CDATA[修改配置文件$ git config --global core.quotepath false # 显示 status 编码 $ git config --global gui.encoding utf-8 # 图形界面编码 $ git config --global i18n.commit.encoding utf-8 # 提交信息编码 $ git config --global i18n.logoutputencoding utf-8 # 输出 log 编码 $ export LESSCHARSET=utf-8 # 最后一条命令是因为 git log 默认使用 less 分页，所以需要 bash 对 less 命令进行 utf-8 编码]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>gitBash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker指南]]></title>
    <url>%2Fpost%2Faaf49e25.html</url>
    <content type="text"><![CDATA[dockerdocker管理的对象是镜像是镜像和容器。 安装ce社区版安装docker依赖包#yum-utils provides the yum-config-manager #device-mapper-persistent-data and lvm2 are required by the devicemapper storage driver yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 添加docker-ce的yum源#默认的镜像 yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo #国内镜像最好使用aliyun yum-config-manager \ --add-repo \ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 关闭docker-ce的nightly版本和test版本默认就是disable这些版本，如果要开启的话执行下面两条语句 #测试版本 yum-config-manager --enable docker-ce-test #每晚一更新的版本 yum-config-manager --enable docker-ce-nightly 更新yum源上面添加源之后最好要更新下yum源缓存 yum makecache fast 安装yum install docker-ce -y 查看是否安装成功docker version 加入开机启动项里#docker安装完之后，默认是不会在开机启动项里的 systemctl enable docker 客户端操作在客户端敲命令，然后将命令发送给服务端，服务端处理 镜像管理拉取镜像#拉取ubuntu镜像 docker pull ubuntu 查看镜像#可以查看本地镜像id，镜像名，镜像创建时间，镜像大小 docker image ls docker images 删除镜像#删除一个镜像 docker image rm -f 镜像id或镜像名或摘要 #批量删除 #比如，我们需要删除所有仓库名为 redis 的镜像 docker image rm $(docker image ls -q redis) 创建镜像 创建目录，是以目录为单位的 在目录里创建Dockerfile文件 构建镜像 #找基础镜像，如果本地如果有直接使用，没有去官方下载 #目录中国需要一个dockerfile文件，从dockerfile创建镜像，用相对目录指定 #-t 镜像的名称 #在build的过程中，没执行一条dockerfile里的指令，就会生成一个layer，最后一个layer是由前面的layer组合而成； docker build -t wuqiyin/centos-nodejs-1 ./ 注意：最完整的镜像命名格式是：registory_url/namespace/镜像名称，其中镜像名称：项目名称：版本号。例如：registory_url:端口/namespace(其实就是目录)/centos:7.1。registyr_url为本地镜像宿主机的地址 上传镜像见仓库部分 容器管理启动由docker镜像生成docker容器 #-P 22,容器随机生成一个宿主机的端口和容器的22端口映射，下次启动时候又变了 #-p 2222:22,宿主机固定2222和和容器的22映射 #--name base,给容器起名字base #-v host_dir:continer_dir，删除容器，不会删除宿主机的目录 #--rm，在容器停止之后删除 #--entrypoint=/bin/bash，该命令会替换dockerfile的ENTRYPOINT #常用命令 #后台运行 docker run -d -p 8080:8080 imageName:tag #前台运行 docker run -it -p 8080:8080 imageName:tag #带有命令,注意命令替代掉Dockerfile里的Cmd命令 docker run -it wuqiyin/cmd:0.1 /bin/bash 由停止状态的容器启动 #处于stop状态的 docker start dockerId 停止docker stop dockerId 查看容器#查看运行中的容器 docker ps #-a查看所有 docker ps -a --filter name=redis #查看所有已经创建的包括终止状态的容器 docker container ls -a 重命名#把redis 命名为 micro-service-redis $ docker rename redis micro-service-redis 查看容器的运行日志docker logs -f 容器id 删除容器#删除一个处于终止状态的容器 docker container rm 容器id #删除一个运行中的容器 docker container -f rm 容器id #清理所有处于终止状态的容器 docker container prune 登录容器(类似ssh)docker exec -it 容器id bash(执行的命令) #退出 exit 挂载数据卷的容器#把本地的目录，挂载到容器的目录下 docker run -p 8080:8080 -d --mount source=my-vol,target=/webapp imageName:tag 查看挂载的信息docker inspect 容器id 仓库公有仓库搜索镜像#例如搜索centos docker search centos 拉取镜像#例如拉取ubuntu docker pull ubuntu 登录dockerhubdocker login 推送到共有仓库 给镜像打标签 docker tag centos-node.js:1.0 wuqiyin/centos-nodejs:1.0 查看打好标签的本地镜像 docker image ls 上传到docker官方镜像仓库 docker push wuqiyin/centos-nodejs 查看是否上传成功 #搜索查看是否存在 docker search wuqiyin 私有仓库启动registry服务默认情况下，会将仓库存放于容器的/tmp/registry（还是说在/var/lib/registry？有待考证！！）目录下，这样如果容器被删除，则存放于容器中的镜像也会丢失，所以我们一般情况下会指定本地一个目录挂载到容器的/tmp/registry下 #官方提供的registry服务 docker run -d 5000:5000 -v /opt/data/registry:/var/lib/registry registry 上传到私有仓库 标记镜像到私有仓库 #tag镜像为私有仓库ip：port，不打tag，push不知道目标ip和端口 $ docker tag ubuntu:lastest 127.0.0.1:5000/centos-nodejs:1.0 上传到私有仓库 $ docker push 127.0.0.1:5000/centos-nodejs:1.0 push报错: http: server gave HTTP response to HTTPS client，修改push的HTTPS要求即可，如下 [root@c1awn01 ~]# vim /etc/docker//daemon.json { &quot;registry-mirrors&quot;: [ &quot;http://9686e306.m.daocloud.io&quot; ], &quot;insecure-registries&quot;: [ &quot;192.168.80.129:5000&quot; ] #增加这个，然后重启docker即可 } 查看镜像 $ curl 127.0.0.1:5000/v2/_catalog 从本地仓库下载镜像docker pull 127.0.0.1:5000/centos-nodejs:1.0 查看仓库中已经上传的镜像curl 127.0.0.1:5000/v2/_catalog 删除本地镜像docker image rm 127.0.0.1:5000/centos-nodejs:1.0 数据卷容器挂载#把本地的目录，挂载到容器的目录下 docker run -p 8080:8080 -d --mount source=my-vol,target=/webapp imageName:tag 查看所有的数据卷docker volume ls 查看数据卷的详细信息docker volume inspect my-vol #在容器的信息里查看挂载信息 docker inspect 容器id docker网络外部访问docker 端口映射任意的地址 #所有ip都可以访问该端口 -p 8080:8080 映射本机指定地址的指定端口 #只有宿主主机本身可以访问该端口 #参数：-p 127.0.0.1:8080:8080 #例如 docker run -p 127.0.0.1:8080:8080 -d centos-nodejs:1.0 映射到主机地址的任意端口 #参数 -p 127.0.0.0::8080 #例如 docker run -p 127.0.0.0::8080 -d centos-nodejs:1.0 查看端口信息 docker port 容器id 8080（端口号） 容器间通信-容器互联docker在启动的时候，会自动在主机上创建一个docker0的虚拟网桥，实际上是linux的一个bridge，可以理解为是一个软件交换机。它会在挂载到它的网口之间进行转发。 创建一个自己的虚拟网桥 docker network create -d bridge my-bridge（网桥起个名字） 创建两个链接到新网桥的两个容器 # --name 给容器启一个名字 # --newwork 容器的网络使用我们自己创建的网桥 # -it 交互模式启动，启动之后会进入容器 # centos 镜像名字 docker run -it --name test5 --network my-bridge centos docker run -it --name test6 --network my-bridge centos 服务端responsity源设置 打开网站https://www.daocloud.io/mirror，里面有教程 执行命令curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io 如果已经启动要重启docker 启动systemctl start docker dockerfile文件指令FROM#指定父镜像(from) FROM centos:centos7.1.1503 MAINTAINER#maintainer #维护者，是谁来维护的 MAINTAINER 名字 &lt;邮件地址&gt; ENV#env #设置环境变量，在dockerfile中可以写多个 #时区 ENV TZ &quot;Asia/Shanghai&quot; #终端模拟器xterm ENV TERM xterm ADD#可以把链接地址或者本地文件复制到container里面 #把压缩包复制到container的时候，自动解压 ADD aliyun-mirror.repo /etc/yum.repos.d/CentOS-Base.repo COPY#只能把本地文件copy到container里面，并且不能自动解压 ADD aliyun-mirror.repo /etc/yum.repos.d/CentOS-Base.repo RUN#执行shell脚本命令 RUN yum install -y curl wget tar bzip2 unzip vim-enhanced passwd sudo yum-utils hostname net-tools rsync man &amp;&amp; \ yum install -y gcc gcc-c++ git make automake cmake patch logrotate python-devel libpng-devel libjpeg-devel &amp;&amp; \ yum install -y --enablerepo=epel pwgen python-pip &amp;&amp; \ yum clean all EXPOSE#容器开放端口，给外部连接使用 EXPOSE 22 EXPOSE 80 443 ENTRYPOINT#entrypoint，一个dockerfile里只有最后一个生效 #container每次启动的时候执行该命令 #数组的格式，进程启动起来pid就唯一 ENTRYPOINT [&quot;/usr/bin/supervisord&quot;, &quot;-n&quot;, &quot;-c&quot;, &quot;/etc/supervisord.conf&quot;] #命令模式,pid为shell的id ENTRYPOINT command param1 param2 注意：docker run -it entrypoint =会覆盖dockerfile里的entrypoint，如果只是简单的执行命令则不会被替换，如docker run -it /bin/bash，中的/bin/bash命令 CMD#数组格式 CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] #为entrypoint提供一个默认的参数，/usr/bin/nginx param1 param2 CMD [&quot;param1&quot;,&quot;param2&quot;] #pid号是shell的pid号 CMD command param1 param2 param3 注意：docker run 命令，该命令会替换掉dockerfile里的cmd命令。 ONBUILD#build本dockerfile的镜像的时候不生效，在其它镜像FROM这个镜像的时候生效 ONBUILD ADD . /app VOLUME#数据卷映射到宿主机 #声明之后就可以在docker run中使用-v hots_dir:/var/lib/mysql启动容器 VOLUME [&quot;/var/lib/mysql&quot;] docker-compose管理的对象是项目，根据docker-compose.yml将多个服务（即容器）构建一个项目。 docker compose安装安装epl软件源yum install -y epel-release 安装python-pipyum install -y python-pip 安装docker composepip install docker-compose 查看docker compse的版本docker-compose version 指令启动#后台的方式启动 docker-compose up -d 查看运行的容器docker-compose ps 查看compose文件含有的镜像docker-compose images 停止项目中正在运行的容器docker-compose stop 删除已经停止的容器docker-compose rm 启动compose项目中的容器docker-compose start 指定项目中容器的启动数量#wordpress 启动3个，db启动2个 docker-compose scale worpress=3 db=2 查看项目中服务对应绑定的端口号docker-compose port wordpress 80 查看项目中服务的日子信息docker-compose logs -f wordpress Registry该镜像容器可以将本地的镜像上传到私有的仓库上面； 部署一个私有的docker registry服务持续集成集成是指软件个人研发的部分向软件整体部分交付，以便尽早发现个人开发部分的问题；部署是代码尽快向可运行的开发/测试节交付，以便尽早测试；交付是指研发尽快向客户交付，以便尽早发现生产环境中存在的问题。如果说等到所有东西都完成了才向下个环节交付，导致所有的问题只能再最后才爆发出来，解决成本巨大甚至无法解决。而所谓的持续，就是说每完成一个完整的部分，就向下个环节交付，发现问题可以马上调整。是的问题不会放大到其他部分和后面的环节。 这种做法的核心思想在于：既然事实上难以做到事先完全了解完整的、正确的需求，那么就干脆一小块一小块的做，并且加快交付的速度和频率，使得交付物尽早在下个环节得到验证。早发现问题早返工。 举个例子，你家装修厨房，其中一项是铺地砖，边角地砖要切割大小。如果一次全切割完再铺上去，发现尺寸有误的话浪费和返工时间就大了，不如切一块铺一块。这就是持续集成。 装修厨房有很多部分，每个部分都有检测手段，如地砖铺完了要测试漏水与否，线路铺完了要通电测试电路通顺，水管装好了也要测试冷水热水。如果全部装完了再测，出现问题可能会互相影响，比如电路不行可能要把地砖给挖开……。那么每完成一部分就测试，这是持续部署。 全部装修完了，你去验收，发现地砖颜色不合意，水池太小，灶台位置不对，返工吗？所以不如没完成一部分，你就去用一下试用验收，这就是持续交付。 -——————- 补充：从敏捷思想中提出的这三个观点，还强调一件事：通过技术手段自动化这三个工作。加快交付速度。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yum常用命令]]></title>
    <url>%2Fpost%2F94fe38d7.html</url>
    <content type="text"><![CDATA[説明 Redhat系 Debian系 更新缓存 yum makecache apt-get update 更新包 yum update apt-get upgrade 检索包 yum search apt-cache search 检索包内文件 yum provides apt-file search 安装指定的包 yum install apt-get install 删除指定的包 yum remove apt-get remove 显示指定包的信息 yum info apt-cache show 显示包所在组的一览 yum grouplist - 显示指定包所在组的信息 yum groupinfo - 安装指定的包组 yum groupinstall - 删除指定的包组 yum groupremove - 参考库的设定文件 /etc/yum.repos.d/* /etc/apt/sources.list 安装完的包的列表 rpm -qa dpkg-query -l 显示安装完的指定包的信息 rpm -qi apt-cache show 安装完的指定包内的文件列表 rpm -ql dpkg-query -L 安装完的包的信赖包的列表 rpm -qR apt-cache depends 安装完的文件信赖的包 rpm -qf dpkg -S]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO SEO优化插件]]></title>
    <url>%2Fpost%2Ff1dca051.html</url>
    <content type="text"><![CDATA[sitemap生成用于生产站点地图 npm install hexo-generator-sitemap --save npm install hexo-generator-baidu-sitemap --save 在博客的站点配置文件_config.yml中添加以下代码 # 自动生成sitemap sitemap: path: sitemap.xml baidusitemap: path: baidusitemap.xml autonofollow自动为出站链接添加nofollow的插件，避免外链 npm install hexo-autonofollow --save 在博客的站点配置文件_config.yml中添加以下代码 nofollow: enable: true exclude: - www.example.fun - 友链地址 百度主动提交npm install hexo-baidu-url-submit --save 在博客的站点配置文件_config.yml中添加以下代码 baidu_url_submit: count: 5 # # 提交最新的五个链接 host: blog.silverwq.top # # 百度站长平台中注册的域名 token: eAWLFXENjvUPUD23 # # 准入秘钥 path: baidu_urls.txt # # 文本文档的地址， 新链接会保存在此文本文档里 百度自动提交将主题配置文件中的baidu_push设置为true # 开起来 baidu_push: true]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php中的闭包和匿名函数]]></title>
    <url>%2Fpost%2F30492970.html</url>
    <content type="text"><![CDATA[匿名函数 (在php5.3.0 或以上才能使用)​ php中的匿名函数(Anonymous functions)， 也叫闭包函数(closures), 允许指定一个没有名称的函数。最常用的就是回调函数的参数值。（http://php.net/manual/zh/functions.anonymous.php） ​ 匿名函数的定义： $closureFunc = function(){ .... }; eg: 把匿名函数赋值给变量，通过变量来调用 $closureFunc = function($str){ echo $str; }; $closureFunc(&quot;hello world!&quot;); 输出： hello world! 闭包 将匿名函数放在普通函数中，也可以将匿名函数返回，这就构成了一个简单的闭包 function closureFunc1(){ $func = function(){ echo &quot;hello&quot;; }; $func(); } closureFunc1(); //输出: hello 在匿名函数中引用局部变量 function closureFunc2(){ $num = 1; $func = function(){ echo $num; }; $func(); } closureFunc2(); //Notice: Undefined variable: num 上面的函数运行后，会报Notice错误，说明我们不能在匿名函数中这样使用局部变量，这时候就要引用一个php的关键字 use， 代码如下 function closureFunc2(){ $num = 1; $func = function() use($num){ echo $num; }; $func(); } closureFunc2(); //输出: 1 2.3 返回匿名函数 function closureFunc3(){ $num = 1; $func = function() use($num){ echo $num; }; return $func; } $func = closureFunc3(); //函数返回匿名函数 $func(); //然后我们在用$func() 调用 //输出: 1 当我们在返回匿名函数时候怎么给匿名函数传参呢？ 其实跟普通函数传参数一样 function closureFunc4(){ $num = 1; $func = function($str) use($num){ echo $num; echo &quot;\n&quot;; echo $str; }; return $func; } $func = closureFunc4(); $func(&quot;hello, closure4&quot;); //输出: //1 //hello, closure4 怎么用闭包来改变上下文引用的变量值？ function closureFunc5(){ $num = 1; $func = function() use($num) { echo &quot;\n&quot;; $num++; echo $num; }; echo &quot;\n&quot;; echo $num; return $func; } $func = closureFunc5(); $func(); $func(); $func(); //输出: // 1 // 2 // 2 // 2 看上面的输入结果，显然没有达到目的， 其实只要加一个 &amp; 引用符号就可以了 function closureFunc5(){ $num = 2; $func = function() use(&amp;$num) { echo &quot;\n&quot;; $num++; echo $num; }; echo &quot;\n&quot;; echo $num; return $func; } $func = closureFunc5(); $func(); $func(); $func(); //输出: // 2 // 3 // 4 // 5 把匿名函数当作参数传递 function callFunc($func){ $func(&quot;argv&quot;); } callFunc(function($str){ echo $str; }) //输出： // argv]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lavarel核心概念]]></title>
    <url>%2Fpost%2F3db89d5f.html</url>
    <content type="text"><![CDATA[容器字面上理解就是装东西的东西，例如：常见的变量、对象属性等都可以算是容器。 当然，有这样一种容器，它存放的不是文本、数值，而是对象、对象的描述（类、接口）或者是提供对象的回调，通过这种容器，我们得以实现许多高级的功能，其中最常提到的，就是 “解耦” 、“依赖注入（DI）”。 IoC 容器IoC：控制反转，由外部负责其依赖需求的行为。 主要职能 其实就是 一个高级的工厂类，用于生产依赖类的； 为系统绑定（bind）可变的部分，用于生产类 生厂（make）类 容器接口，用于标准化 服务提供器服务提供器是所有 Laravel 应用程序引导中心，用于引导和配置各个组件。 特性： boot()，引导 register()，注册服务容器 外观模式外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitignore文件]]></title>
    <url>%2Fpost%2F843cc845.html</url>
    <content type="text"><![CDATA[作用 允许文件是否被git追踪，如果已经被提交了之后再忽略已经提交的文件，则该文件不能被忽略，因为之后忽略没有被追踪的文件； 语法 所有空行或者以 ＃ 开头的行都会被 Git 忽略 可以使用标准的 glob 模式匹配（shell简化的正则表达式） 星号（*）匹配零个或多个任意字符； # 忽略当前目录下的 .a结尾的文件 *.a [abc]匹配任何一个列在方括号中的字符（这个例子） #如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配 #表示匹配所有 0 到 9 的数字 [0-9] #要么匹配一个 a，要么匹配一个 b，要么匹配一个 c [abc] 问号（?）只匹配一个任意字符； # 忽略当前目录下的 后缀包含.ph结尾的文件 *.pp？ 使用两个星号 ** 表示匹配任意中间目录，如： #可以匹配 a/z, a/b/z 或 `a/b/c/z` a/**/z # ignore all .pdf files in the doc/ directory doc/**/*.pdf 匹配模式可以以（/）开头防止递归 # only ignore the TODO file in the current directory, not subdir/TODO /TODO 匹配模式可以以（/）结尾指定目录 # ignore all files in the build/ directory build/ # ignore doc/notes.txt, but not doc/server/arch.txt doc/*.txt 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反 # 忽略 .a 文件 *.a # 但否定忽略 lib.a, 尽管已经在前面忽略了 .a 文件 !lib.a]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git配置]]></title>
    <url>%2Fpost%2F925e341a.html</url>
    <content type="text"><![CDATA[配置#优先级：从低到高 /** * 作用在/etc/gitconfig文件 * 针对整个操作系统 */ git config --system user.name = Wu qiyin /** * ~/.gitconfig 或 ~/.config/git/config 文件 * 只针对用户 */ git config --global user.name = Wu qiyin /** * 当前使用仓库的 Git 目录中的 config 文件（就是 .git/config） * 针对该仓库 */ git config user.name = Wu qiyin 检查配置信息#查看列表，只显示有效的配置 git config --list]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2Fpost%2F423abe9e.html</url>
    <content type="text"><![CDATA[系统帮助git --help #查看命令的帮助 git help commandName 对比diff#此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容 git diff #查看已暂存的将要添加到下次提交里的内容 git diff --staged #配置diff工具 /** * 图像化查看差异，默认vim编辑器打开 * git config -- global diff.tool meld * git config --global difftool.meld.path /c/Program files (x86)/Meld/meld/meldc.exe */ git difftool --tool-help #查看支持什么编辑器 git difftool --staged #等效git diff --staged git init -bare respositoryName.git 配置所有配置项都储存在纯文本文件中，所以 git config 命令其实只是一个提供便捷的命令行接口。通常会使用 --global 标记来针对用户一次配置git软件。 Git 将配置项保存在三个单独的文件中，允许你分别对单个仓库、用户和整个系统设置。 /.git/config – 特定仓库的设置。 ~/.gitconfig – 特定用户的设置。这也是 --global 标记的设置项存放的位置。 $(prefix)/etc/gitconfig – 系统层面的设置。 当这些文件中的配置项冲突时，本地仓库设置覆盖用户设置，用户设置覆盖系统设置。如果你打开期中一份文件，你会看到下面这些： [user] name = John Smith email = john@example.com [alias] st = status co = checkout br = branch up = rebase ci = commit [core] editor = vim 你可以用 git config 手动编辑这些值 查看配置列表git config --list 配置告诉Git你是谁： 定义当前仓库所有提交使用的作者姓名。通常来说，你希望使用 --global 标记设置当前用户的配置项，而不是针对当前仓库。 git config --global user.name &quot;John Smith&quot; 定义当前用户所有提交使用的作者邮箱。 git config --global user.email john@example.com 添加一些快捷方式(别名): git config --global alias.st status git config --global alias.co checkout git config --global alias.br branch git config --global alias.up rebase git config --global alias.ci commit 选择你喜欢的文本编辑器: git config --global core.editor vim 常见问题： 出现warning: LF will be replaced by CRLF in XXXXXXXXXXXXXX.的警告配置 git config --global core.autocrlf false 仓库初始化仓库因为 git clone 创建项目的本地拷贝更为方便，git init 最常见的使用情景就是用于创建中央仓库。 在当前目录下初始化仓库 #将目录初始化仓库 git init #初始化一个裸的 Git 仓库 git init --bare 创建文件夹directory，并且初始化该目录为仓库 git init &lt;directory&gt; #初始化一个裸的 Git 仓库 git init --bare my-project.git 注意：当使用–bare来创建裸仓库时候，目录名称名称用.git结尾，因为目录本身就是.git文件 克隆仓库为了方便起见，clone 自动创建了一个名为 origin 的远程连接，指向原有仓库。这让和中央仓库之间的交互更加简单，为克隆到指定的目录。 克隆本地仓库的 git clone /path/to/repository &lt;directory&gt; 克隆远端服务器上的仓库 #通过 SSH git clone username@host:/path/to/repository &lt;directory&gt; #通过 https git clone https:/path/to/repository.git &lt;directory&gt; 远程仓库如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加： # origin 是 &lt; server &gt; 的别名，取什么名字都可以。 # 第一次设置完之后，之后push的时候，直接使用这个别名即可 git remote add origin &lt;server_url&gt; 查看远程服务器 #默认服务器名称叫origin git remote git remote -v #更加详细 #查看远程仓库的push，fetch的地址，分支 git remote show origin 修改远程服务器 #远程仓库重命名 git remote rename respo_from respo_to #远程仓库修改url git remote set-url origin https://xxx@github.org/hello/etl.git #远程仓库的移除 git remote rm respon_name 检查仓库的状态git status git status 命令显示工作目录和缓存区的状态。你可以看到哪些更改被缓存了，哪些还没有，以及哪些还未被 Git 追踪。status 的输出 不会 告诉你任何已提交到项目历史的信息。如果你想看的话，应该使用 git log 命令。 列出已缓存、未缓存、未追踪的文件： git status status 信息还包括了添加缓存和移除缓存的相关指令，主要有三类 git status 输出： Changes to be committed # On branch master # Changes to be committed: # (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) # #modified: hello.py Changes not staged for commit # Changes not staged for commit: # (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) # (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) # #modified: main.py Untracked files # Untracked files: # (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) # #hello.pyc nothing to commit # nothing to commit (working directory clean) git log git log 命令显示已提交的快照。你可以列出项目历史，筛选，以及搜索特定更改。git status 允许你查看工作目录和缓存区，而 git log 只作用于提交的项目历史。 输出： commit 3157ee3718e180a9476bf2e5cab8e3f1e78a73b7 Author: John Smith commit 后面 40 个字的字符串是提交内容的 SHA-1 校验总和（checksum）。它有两个作用。一是保证提交的正确性——如果它被损坏了，提交会生成一个不同的校验总和。第二，它是提交唯一的标识 ID，是一次具体提交的引用。 ~字符用于表示提交的父节点的相对引用。比如，3157e~1 指向 3157e 前一个提交,HEAD~3 是当前提交的回溯3个节点的提交。 命令： 使用默认格式显示完整地项目历史。如果输出超过一屏，你可以用 空格键 来滚动，按 q 退出。 git log 用 &lt;limit&gt; 限制提交的数量。比如 git log -n 3 只会显示 3 个提交 git log -n &lt;limit&gt; 将每个提交压缩到一行。当你需要查看项目历史的上层情况时这会很有用。 git log --oneline 除了 git log 信息之外，包含哪些文件被更改了，以及每个文件相对的增删行数 git log --stat 显示代表每个提交的一堆信息。显示每个提交全部的差异（diff），这也是项目历史中最详细的视图 git log -p 搜索特定作者的提交。&lt;pattern&gt; 可以是字符串或正则表达式 git log --author=&quot;&lt;pattern&gt;&quot; 只显示发生在 &lt;since&gt; 和 &lt;until&gt; 之间的提交。两个参数可以是提交 ID、分支名、HEAD 或是任何一种引用 git log &lt;since&gt;..&lt;until&gt; #自从2018-08-01开始的 git log 2018-08-01..2018-08-01 #提交id之间 git log 3157e..5ab91 git log 1816..HEAD #..句法是比较分支很有用的工具，不包含前面一个 #显示了在 some-feature 分支而不在 master 分支的所有提交的概览 git log --oneline master..some-feature 只显示包含特定文件的提交。查找特定文件的历史这样做会很方便 git log &lt;file&gt; 还有一些有用的选项。--graph 标记会绘制一幅字符组成的图形，左边是提交，右边是提交信息。--decorate 标记会加上提交所在的分支名称和标签。--oneline 标记将提交信息显示在同一行，一目了然 git log --graph --decorate --oneline 分支的本地操作记录: 查看分支从哪个分支创建出来的， git reflog --date=local | grep &lt;branchname&gt; 基本操作添加git add 命令将工作目录中的变化添加到缓存区。它告诉 Git 你希望下一个提交中包含这个文件的更新。不过，git add 不会实际上并不会改变你的仓库。直到你运行 git commit ，更改都没有真正被记录。 缓存区的作用：缓存允许你把紧密相关的几份更改合并成一份快照，而不是直接提交所有新的更改。也就是说你可以同时进行多个无关的更改，最后分成几次将相关更改添加到缓存区并提交。对于任何版本控制系统来说，保持提交的原子性非常重要，这有利于追踪 bug 以及用最小的代价撤销更改。 一个项目的编写离不开这个基本模式：编辑、缓存和提交。 首先，你在工作目录下编辑你的文件。然后，当你想要备份当前的项目状态时，你使用 git add 缓存更改。最后，当你觉得这个被缓存的副本已经就绪，你使用 git commit 将它提交到项目历史。git reset 命令用于撤销提交或被缓存的快照。 缓存 &lt;文件&gt; 中的更改，准备下次提交 git add &lt;文件&gt; #添加所有文件 git add -A git add * 缓存 &lt;目录&gt; 下的所有更改，准备下次提交 git add &lt;目录&gt; 开始交互式的缓存。你可以将某个文件的其中一处更改加入到下次提交缓存。Git 会显示一系列更改，并等待用户命令。使用 y 缓存某一处更改，使用 n 忽略某一处更改，使用 s 将某一处分割成更小的几份，使用 e 手动编辑某一处更改，使用 q 退出编辑。 git add -p 提交 已经暂存的文件到仓库，-a可以跳过git add暂存操作 #-m,注释 git commit -m &#39;说明信息&#39; #提交时候在说明会显示文件修改内容，该内容在提交时候不会被提交 git commit -v #-a,自动将跟踪的文件暂存 git commit -a -m &#39;备注&#39; #本次提交将和上一次提交作为同一个提交 git commit --amend 推送 #推送到远程仓库名称remote-name的分支branchname git push [remote-name] [branchname] #本地分支master：远程分支master git push --progress &quot;origin&quot; master:master #下次使用git push 即等效下面 git push -u origin master 拉取#拉取并且合并 #通常是从克隆的服务器上抓取，并且合并到当前分支 git pull # 拉取并且删除远程已经不存在的分支 git pull -p 检出git checkout 这个命令有三个不同的作用：检出文件、检出提交和检出分支。 检出master分支 git checkout master git撤销 已经commit到本地仓库，但是还未push，git log查看commit_id #回滚到指定版本且代码还原 git reset --hard [commit_id] #回滚到值版本，不还原代码，代码保留修改 git reset [commit_id] #已经push的代码进行回滚 git revert [commit_id] #取消修改（已修改，未暂存的文件） git checkout -- &lt;file&gt; #取消暂存 git reset HEAD &lt;file&gt; 推送到远程 服务器名称（一般都是origin） 分支名称(本地分支：远程分支) git.exe push --progress &quot;origin&quot; master:master 克隆为了方便起见，clone 自动创建了一个名为 origin 的远程连接，指向原有仓库。这让和中央仓库之间的交互更加简单 git clone url 将位于 &lt;repo&gt; 的仓库克隆到本地机器上的 &lt;directory&gt; 目录 git clone &lt;repo&gt; &lt;directory&gt; 暂存区文件清单中移除 下次提交就可以移除成功，–cached保留本地文件 git rm --cached fileName #删除log目录下的.log结尾的文件，支持glob模式 git rm log/\*.log 重命名git mv oldFileName newFileName 从仓库中检出，放弃修改git checkout -- fileName 拉取合并git pull 分支创建分支git branch branchName #创建iss53分支，并且切换 git checkout -b iss553 查看分支图git log --graph --decorate --oneline --simplify-by-decoration --all 创建的分支推送到远程仓库git push --set-upstream origin 分支名称 切换分支#切换本地分支 git checkout branchName #切换远程分支 git checkout --track origion/分支名 合并分支到当前分支git merge branchName 删除分支#删除本地分支，要先切换到其它分支，再进行删除 git branch -d branchName #强制删除 git branch -D branchName #删除远程分支 git push origin --delete branch_name 查看分支列表#查看本地分支 git branch #查看远程分支 git branch -r #查看所有分支 git branch -a 其它初始化仓库git init -bare respositoryName.git 暂存# 将修改暂存到盏中 git stash # 从栈中把该修改拿出来 git stash pop # 显示栈中的修改内容 git stash show # 显示栈的列表 git stash list # 清空栈 git stash clear]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo插件]]></title>
    <url>%2Fpost%2F5a3fb175.html</url>
    <content type="text"><![CDATA[hexo 搜索功能安装插件 npm install hexo-generator-searchdb --save 修改站点配置文件 search: path: search.xml field: post format: html limit: 10000 修改 主题配置文件 local_search: enable: true]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[liunx常用命令]]></title>
    <url>%2Fpost%2F26175.html</url>
    <content type="text"><![CDATA[ls#查看目录，在当前目录下执行 ls #列表的形式查看目录 ls -l = ll #查看dot文件 ls -a mkdir#递归创建目录 mkdir -p /data/dir du#查看当前目录大小 du -hs tail#文件的最后部分输出 #查看日志后面10行 tail -n -10 logs/err.log #从第10行开始读取 tail -n 10 logs/err.log #自己主动刷新，查看最后10行（退出，按下CTRL+C） tail -f logs/err.log head#显示文件的前10行内容 head /etc/passwd #显示前5行 head -5 /etc/passwd #第5行开始显示接下来的所有内容 head +5 /etc/passwd touch#创建文件，已经存在则更新时间搓 touch file cat#从第一行開始显示档案内容 cat file file2 ... rm#删除文件 rm -rf fileName cp# 复制 #-a 一模一样复制 #-r 复制目录 cp -ar fileName newFileName tar# 解压bz2 tar -jxvf apr-1.5.0.tar.bz2 #解压gz tar -zxvf apr-1.4.5.tar.gz unzip#解压zip unzip -o pcre-8.10.zip df#查看磁盘使用情况 df -h uname# 系统的位数，和内核版本 uname -a free#查看内存使用情况 free -m pingping 127.0.0.1 wgetwget http://..... curlcurl www.baidu.com netstat#查看端口 netstat -ntlp ifconfig#查看网卡 ifconfig ifup#开启网卡 ifup eth0 iptables#关闭iptalbes防火墙 iptables -F history#查看输入过的命令 history clear#清除屏幕 clear ctrl+L tab键#命令补齐 tab键 ctrl+z#后台暂停挂起 ctrl+z #查看被暂停的进程 jobs #将进程置于前台 fg #将进程移大后台 bg ctrl + c#强制停止 ctrl + c ps#查看进程 ps -aux | grep php #显示当前用户运行的所有进程 ps x #显示系统当前运行的所有的进程 ps ax #显示更详细的进程信息 ps u #显示命令的全名，而非一行以内的内容 ps w #显示指定进程的信息 ps u pid ps u $$ ($$为当前shell进程的shell变量) kill#强行终止进程 kill -9 PID kill -KILL PID #多个进程 kill 9 PID1 PID2 .... #根据软件名称强行终止进程 pkill -9 httpd #暂停 kill -STOP pid #被暂停的进程继续 kill -CONT pid id#查看用户Id id userName useradd#添加用户 useradd userName # 创建不可登录用户 useradd -r -g mysql -s /bin/false mysql #添加用户属于某个组 useradd -r -g mysql mysql_gr passwd#修改用户的密码 passwd userName groupadd#添加组 groupadd mysql_gr chmod#修改权限 chmod -R u+w /home/stuser #用户组添加读权限 chmod g+r file #所有者，所属组，其他添加读写执行 chmod guo+rwx file chown#修改所有者所属组 chown -R owner:group /data/mysql find#查找，如果有模式匹配参数的时候，如*，必须有引号 #locate和find的类似，只是locate在系统创建的索引文件中查找，快，但是新创文件可能找不到 find dir -name fileName -print #当前目录，查找php后缀的文件 find . -name &quot;*.php&quot; top#实时查看进程信息 top mv#重命名 mv fileOld fileNewName #移动多个文件到目录 mv file1 ... fileN dir echo#输出到标准输出 echo Hello again cd#设置当前工作目录 cd dir grep#中间命令 #显示文件和输入流中，和参数匹配的行 #输出passwd文件中，包含root的行 grep root /etc/passwd #/etc中，所有包含root的文件 grep root /etc/* less#滚动屏幕显示，more命令的增强版 #空格查看下一屏，B查看上一屏，Q退出 #输出结果可以搜索，/word向前搜索，?word向后搜索，N键跳到下一个匹配 grep ie /usr/share/dict/words | less pwd#查看目录路径 pwd file#查看文件的信息 file fileName man#获去在线帮助,info比较详细 man ls info ls #关键字查找相关手册 man -k keyword ln#创建符号链接，s表示符号链接 ln -s target linkname su#切换角色 su root]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chkconfig服务管理说明]]></title>
    <url>%2Fpost%2F38848.html</url>
    <content type="text"><![CDATA[使用语法#显示所有运行级系统服务的运行状态信息（on或off）。如果指定了name，那么只显示指定的服务在不同运行级的状态。 chkconfig --list [name] #增加一项新的服务。chkconfig确保每个运行级有一项启动(S)或者杀死(K)入口。如有缺少，则会从缺省的init脚本自动建立。 chkconfig --add name #删除服务，并把相关符号连接从/etc/rc[0-6].d删除。 chkconfig --del name #设置某一服务在指定的运行级是被启动，停止还是重置。 chkconfig [--level levels] name 使用范例chkconfig --list #列出所有的系统服务 chkconfig --add httpd #增加httpd服务 chkconfig --del httpd #删除httpd服务 chkconfig --level httpd 2345 on #设置httpd在运行级别为2、3、4、5的情况下都是on（开启）的状态 chkconfig --list #列出系统所有的服务启动情况 chkconfig --list mysqld #列出mysqld服务设置情况 #设定mysqld在等级3和5为开机运行服务，--level 35表示操作只在等级3和5执行，on表示启动，off表示关闭 chkconfig --level 35 mysqld on #设定mysqld在各等级为on，“各等级”包括2、3、4、5等级 chkconfig mysqld on]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>chkConfig</tag>
      </tags>
  </entry>
</search>
